#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include "../src/base.h"
#include "../src/utils.h"
#include "../src/move_gen.h"

#suite types_ts

#tcase global_data_tests

#test C_quick_and_dirty_SB_and_SBA_test
	ck_assert_msg(
		SB.a1 == 1u && SBA[ 0 ] == 1u && // 1 = 2^0
		SB.c2 == 1024u && SBA[ 10 ] == 1024u && // kibi = 2^10
		SB.e3 == 1048576u && SBA[ 20 ] == 1048576u && // mebi = 2^20
		SB.g4 == 1073741824u && SBA[ 30 ] == 1073741824u && // gibi = 2^30
		SB.a6 == 1099511627776u && SBA[ 40 ] == 1099511627776u && // tebi = 2^40
		SB.c7 == 1125899906842624u && SBA[ 50 ] == 1125899906842624u && // pebi = 2^50
		SB.h8 == 9223372036854775808u && SBA[ 63 ] == 9223372036854775808u ); // 2^63

// uint64, unsigned 64-bit integer
#test C_incremental_sum_of_SBA_elements_test
	unsigned long sum = 0;

	for( int i = 0; i < 64; i++ ) {
		sum += SBA[ i ];
		ck_assert_msg( sum == ( (unsigned long) pow( 2, i + 1 ) - 1 ) );
	}

//
// Test case
//
#tcase fen_to_pos_tests

#test C_fen_to_pos_with_std_start_pos_fen
	Pos *p = fen_to_pos( STD_START_POS_FEN );

	ck_assert( p->cm[ EMPTY_SQUARE ] == 0xffffffff0000u );
	ck_assert( p->cm[ WHITE_KING ] == 0x10u );
	ck_assert( p->cm[ WHITE_QUEEN ] == 0x8u );
	ck_assert( p->cm[ WHITE_ROOK ] == 0x81u );
	ck_assert( p->cm[ WHITE_BISHOP ] == 0x24u );
	ck_assert( p->cm[ WHITE_KNIGHT ] == 0x42u );
	ck_assert( p->cm[ WHITE_PAWN ] == 0xff00u );
	ck_assert( p->cm[ BLACK_KING ] == 0x1000000000000000u );
	ck_assert( p->cm[ BLACK_QUEEN ] == 0x800000000000000u );
	ck_assert( p->cm[ BLACK_ROOK ] == 0x8100000000000000u );
	ck_assert( p->cm[ BLACK_BISHOP ] == 0x2400000000000000u );
	ck_assert( p->cm[ BLACK_KNIGHT ] == 0x4200000000000000u );
	ck_assert( p->cm[ BLACK_PAWN ] == 0xff000000000000u );

	// Should be White's turn
	ck_assert( active_color( p ) == 'w' );
	// Castling availability "KQkq"
	ck_assert(
		( p->info & BM_CA_WK ) &&
		( p->info & BM_CA_WQ ) &&
		( p->info & BM_CA_BK ) &&
		( p->info & BM_CA_BQ ) );
	// En passant target square not set
	ck_assert( !( p->info & BM_EPTS_ALL ) );
	// Halfmove clock set to zero
	ck_assert( !( p->info & BM_HMC ) );
	// Fullmove number is 1
	ck_assert( ( p->info & BM_FMN ) == 0x2000000u );

	ck_assert( p->info == 0x10200200001fU );

	free( p );

#test C_fen_to_pos_manually_computed_test_1
	Pos *p = fen_to_pos( "r3k3/8/8/8/4P3/8/8/4K2R b Kq e3 0 100" );

	ck_assert( p->cm[ EMPTY_SQUARE ] == 0xeeffffffefffff6fU );
	ck_assert( p->cm[ WHITE_KING ] == 0x10u );
	ck_assert( p->cm[ WHITE_QUEEN ] == 0 );
	ck_assert( p->cm[ WHITE_ROOK ] == 0x80u );
	ck_assert( p->cm[ WHITE_BISHOP ] == 0 );
	ck_assert( p->cm[ WHITE_KNIGHT ] == 0 );
	ck_assert( p->cm[ WHITE_PAWN ] == 0x10000000u );
	ck_assert( p->cm[ BLACK_KING ] == 0x1000000000000000u );
	ck_assert( p->cm[ BLACK_QUEEN ] == 0 );
	ck_assert( p->cm[ BLACK_ROOK ] == 0x100000000000000u );
	ck_assert( p->cm[ BLACK_BISHOP ] == 0 );
	ck_assert( p->cm[ BLACK_KNIGHT ] == 0 );
	ck_assert( p->cm[ BLACK_PAWN ] == 0 );

	ck_assert( p->info == 0x1020c8000212u );

	free( p );

#define CHESS960_START_POS_TEST( fen, expected_value ) \
ck_assert( !che_fen_validator( fen, CFSV_BF_CHESS960 ) ); \
p = fen_to_pos( fen ); \
ck_assert( value_BM_C960IRPF( p ) == expected_value ); \
free( (Pos *) p );

#test C_fen_to_pos_tested_with_chess960_starting_positions
	const Pos *p;

	CHESS960_START_POS_TEST( STD_START_POS_FEN, 0x81U )
	CHESS960_START_POS_TEST(
		"nnrkbrqb/pppppppp/8/8/8/8/PPPPPPPP/NNRKBRQB w KQkq - 0 1", 0x24U )
	CHESS960_START_POS_TEST(
		"bqnrkrnb/pppppppp/8/8/8/8/PPPPPPPP/BQNRKRNB w KQkq - 0 1", 0x28U )
	CHESS960_START_POS_TEST(
		"qrbnkbnr/pppppppp/8/8/8/8/PPPPPPPP/QRBNKBNR w KQkq - 0 1", 0x82U )

#test C_fen_to_pos_tested_with_NOT_chess960_starting_positions
	const Pos *p;

	CHESS960_START_POS_TEST( "4k3/8/8/8/8/8/8/4K3 w - - 0 50", 0x81U );
	CHESS960_START_POS_TEST(
		"nnrkrbqb/pppppppp/8/8/8/8/PPPPPPPP/NNRKRBQB w KQkq - 0 1", 0x81U )
	CHESS960_START_POS_TEST(
		"nnrkbrbq/pppppppp/8/8/8/8/PPPPPPPP/NNRKBRQB w KQkq - 0 1", 0x81U )
	CHESS960_START_POS_TEST(
		"nrnkbrqb/pppppppp/8/8/8/8/PPPPPPPP/NNRKBRQB w KQkq - 0 1", 0x81U )
	CHESS960_START_POS_TEST(
		"nnrrbkqb/pppppppp/8/8/8/8/PPPPPPPP/NNRRBKQB w Qq - 0 1", 0x81U )
	CHESS960_START_POS_TEST(
		"bqnrkrnb/pppppppp/8/8/8/8/PPPPPPPP/BQNRKRNB w KQkq - 0 2", 0x81U )
	CHESS960_START_POS_TEST(
		"nnrkbrqb/pppppppp/8/8/8/8/PPPPPPPP/NNRKBRQB w Kkq - 0 1", 0x81U )
	CHESS960_START_POS_TEST(
		"qrbnkbnr/pppppppp/8/8/8/8/PPPPPPPP/QRBNKBNR b KQkq - 0 1", 0x81U )

#undef CHESS960_START_POS_TEST

//
// Test case
//
#tcase pos_to_fen_tests

#test C_fen_to_pos_to_fen_inverse_fn_test
	// ck_assert( false );

//
// Test case
//
#tcase active_color_tests

#test C_active_color_works
	Pos *p;

	p = fen_to_pos( STD_START_POS_FEN );
	ck_assert( active_color( p ) == 'w' );
	free( p );

	p = fen_to_pos(
		"rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1" );
	ck_assert( active_color( p ) == 'b' );
	free( p );

	Pos pos_var;

	// The following two tests rely on the implementation detail of
	// BM_AC being the least significant digit of the 'info' uint64_t.
	for( pos_var.info = 0; pos_var.info <= 100; pos_var.info += 2 ) {
		ck_assert( active_color( &pos_var ) == 'b' );
	}
	for( pos_var.info = 1; pos_var.info <= 101; pos_var.info += 2 ) {
		ck_assert( active_color( &pos_var ) == 'w' );
	}

#tcase bitmask_tests

#test C_macro_BM_UNUSED_INFO_BITS_correctly_defined
	ck_assert( BM_UNUSED_INFO_BITS == 0xffffe00000000000U );
	ck_assert( BM_UNUSED_INFO_BITS == ( 0x7ffffUL << 45 ) );

#test C_BM_AC_correctly_defined
	ck_assert( BM_AC == 1u );

#test C_BM_CA_bits_correctly_defined
	ck_assert(
		BM_CA_WK == 2u &&
		( BM_CA_WK << 1 ) == BM_CA_WQ &&
		( BM_CA_WK << 2 ) == BM_CA_BK &&
		( BM_CA_WK << 3 ) == BM_CA_BQ
	);

#test C_macro_BM_CA_ALL_correctly_defined
	ck_assert( BM_CA_ALL == 30u );

#test C_BM_EPTS_bits_correctly_defined
	ck_assert(
		BM_EPTS_FILE_A == 32u &&
		BM_EPTS_FILE_B == ( BM_EPTS_FILE_A << 1 ) &&
		BM_EPTS_FILE_C == ( BM_EPTS_FILE_A << 2 ) &&
		BM_EPTS_FILE_D == ( BM_EPTS_FILE_A << 3 ) &&
		BM_EPTS_FILE_E == ( BM_EPTS_FILE_A << 4 ) &&
		BM_EPTS_FILE_F == ( BM_EPTS_FILE_A << 5 ) &&
		BM_EPTS_FILE_G == ( BM_EPTS_FILE_A << 6 ) &&
		BM_EPTS_FILE_H == ( BM_EPTS_FILE_A << 7 )
	);

#test C_BM_HMC_correctly_defined
	ck_assert( ( BM_HMC >> 13 ) == 4095u );

#test C_BM_FMN_correctly_defined
	ck_assert( ( BM_FMN >> 25 ) == 4095u );

#tcase Chessman_enum_tests

#test C_EMPTY_SQUARE_equals_0
	Chessman cm = EMPTY_SQUARE;
	ck_assert( !cm );

#test C_BLACK_PAWN_equals_12
	Chessman cm = BLACK_PAWN;
	ck_assert( cm == 12 );

#tcase pos_var_sq_integrity_check_tests

#define NULL_CONTENT_POS_VAR \
Pos p; \
for( int i = EMPTY_SQUARE; i <= BLACK_PAWN; i++ ) p.cm[ i ] = 0u; \
p.info = 0u;

#define ASSIGN_AND_ASSERT( sq_name_constant ) \
const char *sq_name = pos_var_sq_integrity_check( &p ); \
ck_assert( sq_name && !strcmp( sq_name_constant, sq_name ) );

#define SEE_SAW_PATTERN_POS_VAR \
Pos see_saw; \
see_saw.cm[ EMPTY_SQUARE ] = 0x8000008000008000u; \
see_saw.cm[ WHITE_KING ] = 0x4000014000014000u; \
see_saw.cm[ WHITE_QUEEN ] = 0x2000022000022000u; \
see_saw.cm[ WHITE_ROOK ] = 0x1000041000041000u; \
see_saw.cm[ WHITE_BISHOP ] = 0x800080800080800u; \
see_saw.cm[ WHITE_KNIGHT ] = 0x400100400100400u; \
see_saw.cm[ WHITE_PAWN ] = 0x200200200200200u; \
see_saw.cm[ BLACK_KING ] = 0x100400100400100u; \
see_saw.cm[ BLACK_QUEEN ] = 0x80800080800080u; \
see_saw.cm[ BLACK_ROOK ] = 0x41000041000041u; \
see_saw.cm[ BLACK_BISHOP ] = 0x22000022000022u; \
see_saw.cm[ BLACK_KNIGHT ] = 0x14000014000014u; \
see_saw.cm[ BLACK_PAWN ] = 0x8000008000008u; \
see_saw.info = 0u;

#test C_pos_var_sq_integrity_check_returns_NULL
	ck_assert( !pos_var_sq_integrity_check(
		fen_to_pos(
			STD_START_POS_FEN ) ) );
	ck_assert( !pos_var_sq_integrity_check(
		fen_to_pos(
			"rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1" ) ) );
	SEE_SAW_PATTERN_POS_VAR
	ck_assert( !pos_var_sq_integrity_check( &see_saw ) );
	// print_pos_var( &see_saw );
	ck_assert( !pos_var_sq_integrity_check(
		fen_to_pos(
			"rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2" ) ) );

#test C_pos_var_sq_integrity_check_returns_a1
	NULL_CONTENT_POS_VAR
	ASSIGN_AND_ASSERT( "a1" )

#test C_pos_var_sq_integrity_check_returns_b1
	NULL_CONTENT_POS_VAR
	p.cm[ EMPTY_SQUARE ] = 0xffffffffffffffffU;
	p.cm[ WHITE_KING ] = 2u;
	ASSIGN_AND_ASSERT( "b1" );

#test C_pos_var_sq_integrity_check_returns_e4
	NULL_CONTENT_POS_VAR
	p.cm[ EMPTY_SQUARE ] = 0xffffffffffffffffU;
	p.cm[ WHITE_KING ] = 0x10000000U;
	p.cm[ BLACK_KING ] = 0x10000000U;
	ASSIGN_AND_ASSERT( "e4" );

#test C_pos_var_sq_integrity_check_returns_h8
	NULL_CONTENT_POS_VAR
	p.cm[ EMPTY_SQUARE ] = 0xffffffffffffffefU;
	p.cm[ BLACK_KING ] = SB.h8;
	p.cm[ WHITE_KING ] = SB.e1;
	ASSIGN_AND_ASSERT( "h8" )

#tcase sq_set_of_file_tests

#test C_sq_set_of_file_test
	const Bitboard file_a = 0x101010101010101U;
	for( int file = 'a'; file <= 'h'; file++ ) {
		ck_assert( sq_set_of_file( file ) == ( file_a << ( file - 'a' ) ) );
	}

#tcase sq_set_of_rank_tests

#test C_sq_set_of_rank_test
	const Bitboard rank_1 = 0xffU;
	for( int rank = '1'; rank <= '8'; rank++ ) {
		ck_assert( sq_set_of_rank( rank ) ==
			( rank_1 << ( ( rank - 'a' ) * 8 ) ) );
	}

#tcase SS_DIAG_tests

#test C_SS_DIAG_constants_tested_with_sq_navigator

Bitboard sq_bit = sq_name_to_sq_bit( "h1" ), bb;
int index = 0;
while( true ) {
	bb = 0u;
	char *sq = (char *) sq_bit_to_sq_name( sq_bit );

	do {
		bb |= sq_name_to_sq_bit( sq );
	} while( ( sq = (char *) sq_navigator( sq, NORTHEAST ) ) );
	ck_assert( bb == sq_set_of_diag( index ) );
	++index;

	if( sq_bit == sq_name_to_sq_bit( "a8" ) )
		break;
	else if( sq_bit < sq_name_to_sq_bit( "a2" ) &&
			sq_bit != sq_name_to_sq_bit( "a1" ) )
		sq_bit >>= 1;
	else
		sq_bit <<= 8;
}

#test C_SS_DIAG_constants_add_up_to_UINT64_MAX
	ck_assert( UINT64_MAX ==
		SS_DIAG_H1H1 + SS_DIAG_G1H2 + SS_DIAG_F1H3 + SS_DIAG_E1H4 + SS_DIAG_D1H5 +
		SS_DIAG_C1H6 + SS_DIAG_B1H7 + SS_DIAG_A1H8 + SS_DIAG_A2G8 + SS_DIAG_A3F8 +
		SS_DIAG_A4E8 + SS_DIAG_A5D8 + SS_DIAG_A6C8 + SS_DIAG_A7B8 + SS_DIAG_A8A8 );

#tcase SS_ANTIDIAG_tests

#test C_SS_ANTIDIAG_constants_tested_with_sq_navigator

Bitboard sq_bit = sq_name_to_sq_bit( "a1" ), bb;
int index = 0;
while( true ) {
	bb = 0u;
	char *sq = (char *) sq_bit_to_sq_name( sq_bit );

	do {
		bb |= sq_name_to_sq_bit( sq );
	} while( ( sq = (char *) sq_navigator( sq, NORTHWEST ) ) );
	ck_assert( bb == sq_set_of_antidiag( index ) );
	++index;

	if( sq_bit == sq_name_to_sq_bit( "h8" ) )
		break;
	else if( sq_bit < sq_name_to_sq_bit( "h1" ) )
		sq_bit <<= 1;
	else
		sq_bit <<= 8;
}

#test C_SS_ANTIDIAG_constants_add_up_to_UINT64_MAX
	ck_assert( UINT64_MAX ==
		SS_ANTIDIAG_A1A1 + SS_ANTIDIAG_B1A2 + SS_ANTIDIAG_C1A3 +
		SS_ANTIDIAG_D1A4 + SS_ANTIDIAG_E1A5 + SS_ANTIDIAG_F1A6 +
		SS_ANTIDIAG_G1A7 + SS_ANTIDIAG_H1A8 + SS_ANTIDIAG_H2B8 +
		SS_ANTIDIAG_H3C8 + SS_ANTIDIAG_H4D8 + SS_ANTIDIAG_H5E8 +
		SS_ANTIDIAG_H6F8 + SS_ANTIDIAG_H7G8 + SS_ANTIDIAG_H8H8
	);

#tcase sq_set_of_diag_tests

#test C_sq_set_of_diag_comprehensive_input_test
	// ck_assert( sq_set_of_diag( -1 ) == 0 );
	ck_assert( sq_set_of_diag( 0 ) == SB.h1 );
	ck_assert( sq_set_of_diag( 1 ) == ( SB.g1 | SB.h2 ) );
	ck_assert( sq_set_of_diag( 2 ) == ( SB.f1 | SB.g2 | SB.h3 ) );
	ck_assert( sq_set_of_diag( 3 ) == ( SB.e1 | SB.f2 | SB.g3 | SB.h4 ) );
	ck_assert( sq_set_of_diag( 4 ) ==
		( SB.d1 | SB.e2 | SB.f3 | SB.g4 | SB.h5 ) );
	ck_assert( sq_set_of_diag( 5 ) ==
		( SB.c1 | SB.d2 | SB.e3 | SB.f4 | SB.g5 | SB.h6 ) );
	ck_assert( sq_set_of_diag( 6 ) ==
		( SB.b1 | SB.c2 | SB.d3 | SB.e4 | SB.f5 | SB.g6 | SB.h7 ) );
	ck_assert( sq_set_of_diag( 7 ) ==
		( SB.a1 | SB.b2 | SB.c3 | SB.d4 | SB.e5 | SB.f6 | SB.g7 | SB.h8 ) );
	ck_assert( sq_set_of_diag( 8 ) ==
		( SB.a2 | SB.b3 | SB.c4 | SB.d5 | SB.e6 | SB.f7 | SB.g8 ) );
	ck_assert( sq_set_of_diag( 9 ) ==
		( SB.a3 | SB.b4 | SB.c5 | SB.d6 | SB.e7 | SB.f8 ) );
	ck_assert( sq_set_of_diag( 10 ) ==
		( SB.a4 | SB.b5 | SB.c6 | SB.d7 | SB.e8 ) );
	ck_assert( sq_set_of_diag( 11 ) == ( SB.a5 | SB.b6 | SB.c7 | SB.d8 ) );
	ck_assert( sq_set_of_diag( 12 ) == ( SB.a6 | SB.b7 | SB.c8 ) );
	ck_assert( sq_set_of_diag( 13 ) == ( SB.a7 | SB.b8 ) );
	ck_assert( sq_set_of_diag( 14 ) == SB.a8 );
	// ck_assert( sq_set_of_diag( 15 ) == 0 );

#tcase sq_set_of_antidiag_tests

#test C_sq_set_of_antidiag_comprehensive_input_test
	// ck_assert( sq_set_of_antidiag( -1 ) == 0 );
	ck_assert( sq_set_of_antidiag( 0 ) == SB.a1 );
	ck_assert( sq_set_of_antidiag( 1 ) == ( SB.b1 | SB.a2 ) );
	ck_assert( sq_set_of_antidiag( 2 ) == ( SB.c1 | SB.b2 | SB.a3 ) );
	ck_assert( sq_set_of_antidiag( 3 ) == ( SB.d1 | SB.c2 | SB.b3 | SB.a4 ) );
	ck_assert( sq_set_of_antidiag( 4 ) ==
		( SB.e1 | SB.d2 | SB.c3 | SB.b4 | SB.a5 ) );
	ck_assert( sq_set_of_antidiag( 5 ) ==
		( SB.f1 | SB.e2 | SB.d3 | SB.c4 | SB.b5 | SB.a6 ) );
	ck_assert( sq_set_of_antidiag( 6 ) ==
		( SB.g1 | SB.f2 | SB.e3 | SB.d4 | SB.c5 | SB.b6 | SB.a7 ) );
	ck_assert( sq_set_of_antidiag( 7 ) ==
		( SB.h1 | SB.g2 | SB.f3 | SB.e4 | SB.d5 | SB.c6 | SB.b7 | SB.a8 ) );
	ck_assert( sq_set_of_antidiag( 8 ) ==
		( SB.h2 | SB.g3 | SB.f4 | SB.e5 | SB.d6 | SB.c7 | SB.b8 ) );
	ck_assert( sq_set_of_antidiag( 9 ) ==
		( SB.h3 | SB.g4 | SB.f5 | SB.e6 | SB.d7 | SB.c8 ) );
	ck_assert( sq_set_of_antidiag( 10 ) ==
		( SB.h4 | SB.g5 | SB.f6 | SB.e7 | SB.d8 ) );
	ck_assert( sq_set_of_antidiag( 11 ) == ( SB.h5 | SB.g6 | SB.f7 | SB.e8 ) );
	ck_assert( sq_set_of_antidiag( 12 ) == ( SB.h6 | SB.g7 | SB.f8 ) );
	ck_assert( sq_set_of_antidiag( 13 ) == ( SB.h7 | SB.g8 ) );
	ck_assert( sq_set_of_antidiag( 14 ) == SB.h8 );
	// ck_assert( sq_set_of_antidiag( 15 ) == 0 );

#tcase ss_white_army_tests

#test C_ss_white_army_std_start_pos
	ck_assert( ss_white_army( fen_to_pos( STD_START_POS_FEN ) ) ==
		0xffffU );

#tcase ss_black_army_tests

#test C_ss_black_army_std_start_pos
	ck_assert( ss_black_army( fen_to_pos( STD_START_POS_FEN ) ) ==
		0xffff000000000000U );

#tcase SQ_NAV_tests

#test C_SQ_NAV_basic_integrity_test
	int num_of_valid_elements = 0, num_of_valid_non_zero_elements = 0;

	for( int i = 0; i < 64; i++ ) {
		for( enum sq_dir d = NORTH; d <= ELEVEN_OCLOCK; d++ ) {
			Bitboard bb = SQ_NAV[ i ][ d ];
			if( !bb || bb_is_sq_bit( bb ) ) {
				++num_of_valid_elements;
				if( bb )
					++num_of_valid_non_zero_elements;

				continue;
			}

			ck_assert( false );
		}
	}

	if( num_of_valid_elements != 1024 || num_of_valid_non_zero_elements != 756 )
		ck_assert( false );

#test C_SQ_NAV_comprehensive_test_with_ALT_sq_navigator
	for( int row = 0; row < 64; row++ ) {
		const char *origin_sq = SNA[ row ];
		for( int col = 0; col < 16; col++ ) {
			const char *sq_in_dir =
				ALT_sq_navigator( origin_sq, (enum sq_dir) col );

			const Bitboard sq_bit = sq_in_dir ? sq_name_to_sq_bit(
				sq_in_dir ) : 0u;
			ck_assert( SQ_NAV[ row ][ col ] == sq_bit );
		}
	}

#test C_SQ_NAV_comprehensive_test_with_KING_SQS_and_KNIGHT_SQS
	for( int row = 0; row < 64; row++ ) {
		Bitboard bb = 0u;
		for( int col = 0; col < 16; col++ ) {
			bb |= SQ_NAV[ row ][ col ];
		}
		ck_assert( bb == ( KING_SQS[ row ] | KNIGHT_SQS[ row ] ) );
	}

#tcase sq_nav_tests

#test C_sq_nav_comprehensive_test_with_KING_SQS_and_KNIGHT_SQS
	for( int i = 0; i < 64; i++ ) {
		Bitboard bb = 0;
		for( int dir = 0; dir < 16; dir++ ) {
			bb |= sq_nav( SBA[ i ], dir );
		}
		ck_assert( bb == ( KING_SQS[ i ] | KNIGHT_SQS[ i ] ) );
	}

//
// Test case
//
// NOTE: Also set_BM_C960IRPF() gets tested along the way
#tcase value_BM_C960IRPF_tests

#test C_value_BM_C960IRPF_test
	Pos *p = fen_to_pos( STD_START_POS_FEN );
	ck_assert( value_BM_C960IRPF( p ) == 0x81U );
	set_BM_C960IRPF( &p->info, 0xffU );
	ck_assert( value_BM_C960IRPF( p ) == 255U );
	set_BM_C960IRPF( &p->info, 0 );
	ck_assert( !value_BM_C960IRPF( p ) );
	set_BM_C960IRPF( &p->info, 0xaaU );
	ck_assert( value_BM_C960IRPF( p ) == 0xaaU );
	set_BM_C960IRPF( &p->info, 0x8U );
	ck_assert( value_BM_C960IRPF( p ) == 0x8U );
	set_BM_C960IRPF( &p->info, 1 );
	ck_assert( value_BM_C960IRPF( p ) == 1 );

//
// Test case
//
#tcase cma_to_eppf_tests

#define CMA_TO_EPPF_TEST( empty, wking, wqueen, wrook, wbishop, wknight, wpawn, \
	bking, bqueen, brook, bbishop, bknight, bpawn, expected_eppf ) \
Bitboard cm[ 13 ]; Bitboard *p = cm; char eppf[ PPF_MAX_LENGTH + 1 ]; \
*p++ = empty; *p++ = wking; *p++ = wqueen; *p++ = wrook; *p++ = wbishop; \
*p++ = wknight; *p++ = wpawn; *p++ = bking; *p++ = bqueen; *p++ = brook; \
*p++ = bbishop; *p++ = bknight; *p++ = bpawn; \
cma_to_eppf( cm, eppf ); \
ck_assert( !strcmp( eppf, expected_eppf ) );

#test C_cma_to_eppf_tested_with_std_start_pos_pp
	CMA_TO_EPPF_TEST( 0xffffffff0000U, 0x10U, 0x8U, 0x81U, 0x24U, 0x42U, 0xff00U,
		0x1000000000000000U, 0x800000000000000U, 0x8100000000000000U,
		0x2400000000000000U, 0x4200000000000000U, 0xff000000000000U,
		"rnbqkbnr/pppppppp/--------/--------/--------/--------/PPPPPPPP/RNBQKBNR" )

#test C_cma_to_eppf_tested_with_personally_significant_pp
	CMA_TO_EPPF_TEST( 0xbf6a3feeddfdd97bU, 0x4U, 0x400000000000U, 0x1000000080U, 0, 0,
		0x800000022600U, 0x4000000000000000U, 0x4000000000000U, 0x1000000000000U,
		0x10000000000000U, 0x80000000000000U, 0x122000000U,
		"------k-/r-q-b--n/------QP/p---R---/-p---p--/-P------/-PP--P--/--K----R" )

#undef CMA_TO_EPPF_TEST

//
// Test case
//
#tcase eppf_to_cma_tests

#define EPPF_TO_CMA_TEST( input_eppf, empty, wking, wqueen, wrook, wbishop, \
	wknight, wpawn, bking, bqueen, brook, bbishop, bknight, bpawn ) \
Bitboard cm[ 13 ]; \
eppf_to_cma( input_eppf, cm ); \
ck_assert( cm[ EMPTY_SQUARE ] == empty && cm[ WHITE_KING ] == wking && \
	cm[ WHITE_QUEEN ] == wqueen && cm[ WHITE_ROOK ] == wrook && \
	cm[ WHITE_BISHOP ] == wbishop && cm[ WHITE_KNIGHT ] == wknight && \
	cm[ WHITE_PAWN ] == wpawn && cm[ BLACK_KING ] == bking && \
	cm[ BLACK_QUEEN ] == bqueen && cm[ BLACK_ROOK ] == brook && \
	cm[ BLACK_BISHOP ] == bbishop && cm[ BLACK_KNIGHT ] == bknight && \
	cm[ BLACK_PAWN ] == bpawn );

#test C_eppf_to_cma_tested_with_std_start_pos_pp
	EPPF_TO_CMA_TEST(
		"rnbqkbnr/pppppppp/--------/--------/--------/--------/PPPPPPPP/RNBQKBNR",
		0xffffffff0000U, 0x10U, 0x8U, 0x81U, 0x24U, 0x42U, 0xff00U, 0x1000000000000000U,
		0x800000000000000U, 0x8100000000000000U, 0x2400000000000000U,
		0x4200000000000000U, 0xff000000000000U )

#test C_eppf_to_cma_tested_with_personally_significant_pp
	EPPF_TO_CMA_TEST(
		"------k-/r-q-b--n/------QP/p---R---/-p---p--/-P------/-PP--P--/--K----R",
		0xbf6a3feeddfdd97bU, 0x4U, 0x400000000000U, 0x1000000080U, 0, 0,
		0x800000022600U, 0x4000000000000000U, 0x4000000000000U, 0x1000000000000U,
		0x10000000000000U, 0x80000000000000U, 0x122000000U )

#undef EPPF_TO_CMA_TEST

//
// Test case
//
#tcase cma_to_eppf_and_eppf_to_cma_inverse_fn_tests

#define GAME_OF_THE_CENTURY_EPPF \
"r---r-k-/pp---pbp/-qp---p-/--B-----/--BP--b-/Q-n--N--/P----PPP/---R-K-R"

#define GAME_OF_THE_CENTURY_CMA { 0xae1cb9fbb3da1e57U, 0x20U, 0x10000U, 0x88U, \
0x404000000U, 0x200000U, 0x800e100U, 0x4000000000000000U, 0x20000000000U, \
0x1100000000000000U, 0x40000040000000U, 0x40000U, 0xa3440000000000U }

#test C_inner_fn_cma_to_eppf_outer_fn_eppf_to_cma
	const Bitboard century_cma[] = GAME_OF_THE_CENTURY_CMA;
	char writable_eppf[ PPF_MAX_LENGTH + 1 ];
	Bitboard writable_cma[ 13 ];

	cma_to_eppf( century_cma, writable_eppf );
	eppf_to_cma( writable_eppf, writable_cma );

	for( int i = 0; i < 13; i++ )
		ck_assert( century_cma[ i ] == writable_cma[ i ] );

#test C_inner_fn_eppf_to_cma_outer_fn_cma_to_eppf
	const char century_eppf[] = GAME_OF_THE_CENTURY_EPPF;
	char writable_eppf[ PPF_MAX_LENGTH + 1 ];
	Bitboard writable_cma[ 13 ];

	eppf_to_cma( century_eppf, writable_cma );
	cma_to_eppf( writable_cma, writable_eppf );

	ck_assert( !strcmp( GAME_OF_THE_CENTURY_EPPF, writable_eppf ) );

#undef GAME_OF_THE_CENTURY_EPPF
#undef GAME_OF_THE_CENTURY_CMA

//
// Test case
//
#tcase misc_tests

#test C_left_shifting_gives_expected_results
	// 10952704 = 1337 * 2^13
	ck_assert( 10952704 == ( 1337u << 13 ) );
