#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <ctype.h>
#include <assert.h>

#include "../src/base.h"
#include "../src/utils.h"
#include "../src/move_gen.h"
#include "../src/extra.h"
#include "../src/validation.h"

char *
create_APM_DATA_duplicate()
{
    char *dup = (char *) malloc( 10000 * sizeof(char) );
    assert(dup);

    char *ptr = dup;

    for( int file = 0; file <= 7; file++ ) {
        for( int rank = 0; rank <= 56; rank += 8 ) {
            int src = file + rank;
            assert( src >= 0 && src <= 63 );
            Bitboard dest_sqs = (
                ROOK_SQS[src] | BISHOP_SQS[src] | KNIGHT_SQS[src] );
            for( int file = 0; file <= 7; file++ ) {
                for( int rank = 0; rank <= 56; rank += 8 ) {
                    int dest = file + rank;
                    assert( dest >= 0 && dest <= 63 );

                    if( !(SBA[dest] & dest_sqs) ) continue;

                    ptr[0] = SNA[src][0], ptr[1] = SNA[src][1],
                        ptr[2] = SNA[dest][0], ptr[3] = SNA[dest][1];

                    ptr += 4;
                }
            }
        }
    }

    *ptr = '\0';

    assert( (ptr - dup) == (int) strlen(APM_DATA) );
    return dup;
}

#suite types_ts

//
// Test case
//
#tcase global_data_tests

#test C_quick_and_dirty_SB_and_SBA_test
    ck_assert_msg(
        SB.a1 == 1u && SBA[0] == 1u && // 1 = 2^0
        SB.c2 == 1024u && SBA[10] == 1024u && // kibi = 2^10
        SB.e3 == 1048576u && SBA[20] == 1048576u && // mebi = 2^20
        SB.g4 == 1073741824u && SBA[30] == 1073741824u && // gibi = 2^30
        SB.a6 == 1099511627776u && SBA[40] == 1099511627776u && // tebi = 2^40
        SB.c7 == 1125899906842624u && SBA[50] == 1125899906842624u && // pebi = 2^50
        SB.h8 == 9223372036854775808u && SBA[63] == 9223372036854775808u ); // 2^63

#test C_incremental_sum_of_SBA_elements_test
    unsigned long sum = 0;

    for( int i = 0; i < 64; i++ ) {
        sum += SBA[ i ];
        ck_assert_msg( sum == ( (unsigned long) pow( 2, i + 1 ) - 1 ) );
    }

//
// Test case
//
#tcase fen_to_pos_tests

#define PPA_CHECK( \
        exp_es, \
        exp_wk, exp_wq, exp_wr, exp_wb, exp_wn, exp_wp, \
        exp_bk, exp_bq, exp_br, exp_bb, exp_bn, exp_bp ) \
    ck_assert( p->ppa[EMPTY_SQUARE] == (exp_es) ); \
    ck_assert( p->ppa[WHITE_KING] == (exp_wk) ); \
    ck_assert( p->ppa[WHITE_QUEEN] == (exp_wq) ); \
    ck_assert( p->ppa[WHITE_ROOK] == (exp_wr) ); \
    ck_assert( p->ppa[WHITE_BISHOP] == (exp_wb) ); \
    ck_assert( p->ppa[WHITE_KNIGHT] == (exp_wn) ); \
    ck_assert( p->ppa[WHITE_PAWN] == (exp_wp) ); \
    ck_assert( p->ppa[BLACK_KING] == (exp_bk) ); \
    ck_assert( p->ppa[BLACK_QUEEN] == (exp_bq) ); \
    ck_assert( p->ppa[BLACK_ROOK] == (exp_br) ); \
    ck_assert( p->ppa[BLACK_BISHOP] == (exp_bb) ); \
    ck_assert( p->ppa[BLACK_KNIGHT] == (exp_bn) ); \
    ck_assert( p->ppa[BLACK_PAWN] == (exp_bp) );

#define CASTLING_RIGHTS_CHECK( exp_K, exp_Q, exp_k, exp_q ) \
    ck_assert( has_castling_right( p, "white", "kingside" ) == exp_K ); \
    ck_assert( has_castling_right( p, "white", "queenside" ) == exp_Q ); \
    ck_assert( has_castling_right( p, "black", "kingside" ) == exp_k ); \
    ck_assert( has_castling_right( p, "black", "queenside" ) == exp_q );

#define REMAINING_FOUR_FIELDS( exp_wt, exp_epts, exp_hmc, exp_fmn ) \
    ck_assert( (!exp_wt && !whites_turn(p)) || (exp_wt && whites_turn(p)) ), \
    ck_assert( epts(p) == exp_epts ), ck_assert( p->hmc == exp_hmc ), \
    ck_assert( p->fmn == exp_fmn );

#define IRP_CHECK( exp_queenside_value, exp_kingside_value, \
        exp_queenside_sq_bit, exp_kingside_sq_bit ) \
    ck_assert( p->irp[0] == exp_queenside_value ); \
    ck_assert( p->irp[1] == exp_kingside_value ); \
    ck_assert( SBA[sq_bit_index(p->irp[0])] == exp_queenside_sq_bit ); \
    ck_assert( SBA[sq_bit_index(p->irp[1])] == exp_kingside_sq_bit );

#test C_fen_to_pos_with_std_start_pos_fen
    Pos *p = fen_to_pos( FEN_STD_START_POS );

    PPA_CHECK( 0xffffffff0000,
        0x10, 0x8, 0x81, 0x24, 0x42, 0xff00,
        0x1000000000000000, 0x800000000000000, 0x8100000000000000,
        0x2400000000000000, 0x4200000000000000, 0xff000000000000 )
    CASTLING_RIGHTS_CHECK( true, true, true, true )
    ck_assert( p->turn_and_ca_flags == 0x8f );
    REMAINING_FOUR_FIELDS( true, 0, 0, 1 )

    // Duplicate testing to make sure the above macro works as expected
    ck_assert( whites_turn(p) ), ck_assert( !epts(p) ),
    ck_assert( !p->hmc ), ck_assert( p->fmn == 1 );

    IRP_CHECK( 1, 0x80, SB.a1, SB.h1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_1
    Pos *p = fen_to_pos( "r3k3/8/8/8/4P3/8/8/4K2R b Kq e3 0 100" );

    PPA_CHECK( 0xeeffffffefffff6f,
        0x10, 0, 0x80, 0, 0, 0x10000000,
        0x1000000000000000, 0, 0x100000000000000, 0, 0, 0 )
    CASTLING_RIGHTS_CHECK( true, false, false, true )
    ck_assert( p->turn_and_ca_flags == 9 );
    REMAINING_FOUR_FIELDS( false, SB.e3, 0, 100 )

    // Duplicate testing to make sure the above macro works as expected
    ck_assert( !whites_turn(p) ), ck_assert( epts(p) == SB.e3 ),
        ck_assert( !p->hmc ), ck_assert( p->fmn == 100 );

    IRP_CHECK( 1, 0x80, SB.a1, SB.h1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_2
    Pos *p = fen_to_pos( "8/8/8/k7/P7/8/8/K7 b - a3 0 50" );

    PPA_CHECK( 0xfffffffefefffffe,
        1, 0, 0, 0, 0, 0x1000000,
        0x100000000, 0, 0, 0, 0, 0 )
    CASTLING_RIGHTS_CHECK( false, false, false, false )
    ck_assert( !p->turn_and_ca_flags );
    REMAINING_FOUR_FIELDS( false, SB.a3, 0, 50 )

    // Duplicate testing to make sure the above macro works as expected
    ck_assert( !whites_turn(p) ), ck_assert( epts(p) == SB.a3 ),
        ck_assert( !p->hmc ), ck_assert( p->fmn == 50 );

    IRP_CHECK( 1, 0x80, SB.a1, SB.h1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_3
    Pos *p = fen_to_pos( "5rk1/8/8/6p1/8/8/8/6KR w Hf g6 0 75" );

    PPA_CHECK( 0x9fffffbfffffff3f,
        0x40, 0, 0x80, 0, 0, 0,
        0x4000000000000000, 0, 0x2000000000000000, 0, 0, 0x4000000000 )
    CASTLING_RIGHTS_CHECK( true, false, false, true )
    ck_assert( p->turn_and_ca_flags == 0x89 );
    REMAINING_FOUR_FIELDS( true, SB.g6, 0, 75 )
    IRP_CHECK( 0x20, 0x80, SB.f1, SB.h1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_4
    Pos *p = fen_to_pos( "4rrk1/8/8/6p1/8/Q7/8/5RKR w FHf g6 0 75" );

    PPA_CHECK( 0x8fffffbffffeff1f,
        0x40, 0x10000, 0xa0, 0, 0, 0,
        0x4000000000000000, 0, 0x3000000000000000, 0, 0, 0x4000000000 )
    CASTLING_RIGHTS_CHECK( true, true, false, true )
    ck_assert( p->turn_and_ca_flags == 0x8d );
    REMAINING_FOUR_FIELDS( true, SB.g6, 0, 75 )
    IRP_CHECK( 0x20, 0x80, SB.f1, SB.h1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_5
    Pos *p = fen_to_pos(
        "brnqkbrn/pppppppp/8/8/8/8/PPPPPPPP/BRNQKBRN w BGbg - 0 1" );

    PPA_CHECK( SS_RANK_3 | SS_RANK_4 | SS_RANK_5 | SS_RANK_6,
        0x10, 0x8, 0x42, 0x21, 0x84, SS_RANK_2,
        0x1000000000000000, 0x800000000000000, 0x4200000000000000,
        0x2100000000000000, 0x8400000000000000, SS_RANK_7 )
    CASTLING_RIGHTS_CHECK( true, true, true, true )
    ck_assert( p->turn_and_ca_flags == 0x8f );
    REMAINING_FOUR_FIELDS( true, 0, 0, 1 )
    IRP_CHECK( 2, 0x40, SB.b1, SB.g1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_6
    Pos *p = fen_to_pos(
        "b1n1k1r1/p1pq1ppp/6n1/1rb1p3/8/1PN3N1/P1PP1PPP/BR1QK1R1 w GBg - 0 9" );

    PPA_CHECK( 0xaa12bfe9ffb912a4,
        0x10, 0x8, 0x42, 1, 0x440000, 0x2ed00,
        0x1000000000000000, 0x8000000000000, 0x4000000200000000,
        0x100000400000000, 0x400400000000000, 0xe5001000000000 )
    CASTLING_RIGHTS_CHECK( true, true, true, false )
    ck_assert( p->turn_and_ca_flags == 0x8e );
    REMAINING_FOUR_FIELDS( true, 0, 0, 9 )
    IRP_CHECK( 2, 0x40, SB.b1, SB.g1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_7
    Pos *p = fen_to_pos(
        "b1n2rk1/p1p2ppp/1q4n1/2b1p3/2P5/1P6/P2P1PPP/BR1QK1RN w BG - 3 12" );

    PPA_CHECK( 0x9a1abdebfbfd1624,
        0x10, 0x8, 0x42, 1, 0x80, 0x402e900,
        0x4000000000000000, 0x20000000000, 0x2000000000000000,
        0x100000400000000, 0x400400000000000, 0xe5001000000000 )
    CASTLING_RIGHTS_CHECK( true, true, false, false )
    ck_assert( p->turn_and_ca_flags == 0x8c );
    REMAINING_FOUR_FIELDS( true, 0, 3, 12 )
    IRP_CHECK( 2, 0x40, SB.b1, SB.g1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_8
    Pos *p = fen_to_pos(
        "b4rk1/p1p2ppp/1q1n2n1/2b1p3/2P3Q1/1P6/P2P1PPP/BR3RKN b - - 6 13" );

    PPA_CHECK( 0x9e1ab5ebbbfd161c,
        0x40, 0x40000000, 0x22, 1, 0x80, 0x402e900,
        0x4000000000000000, 0x20000000000, 0x2000000000000000,
        0x100000400000000, 0x480000000000, 0xe5001000000000 )
    CASTLING_RIGHTS_CHECK( false, false, false, false )
    ck_assert( !p->turn_and_ca_flags );
    REMAINING_FOUR_FIELDS( false, 0, 6, 13 )
    IRP_CHECK( 1, 0x80, SB.a1, SB.h1 )

    free(p);

#test C_fen_to_pos_manually_computed_test_9
    Pos *p = fen_to_pos( "2k5/8/8/2p5/8/8/8/2KR4 w D c6 0 50" );

    PPA_CHECK( 0xfbfffffbfffffff3,
        4, 0, 8, 0, 0, 0,
        0x400000000000000, 0, 0, 0, 0, 0x400000000 )
    CASTLING_RIGHTS_CHECK( true, false, false, false )
    ck_assert( p->turn_and_ca_flags == 0x88 );
    REMAINING_FOUR_FIELDS( true, SB.c6, 0, 50 )
    IRP_CHECK( 1, 8, SB.a1, SB.d1 )

    free(p);

#undef PPA_CHECK
#undef CASTLING_RIGHTS_CHECK
#undef REMAINING_FOUR_FIELDS
#undef IRP_CHECK

//
// Test case
//
#tcase pos_to_fen_tests

#test C_fen_to_pos_to_fen_inverse_fn_test
    ck_assert( true );

//
// Test case
//
#tcase whites_turn_tests

#test C_whites_turn_works
    Pos *p;

    p = fen_to_pos( FEN_STD_START_POS );
    ck_assert( whites_turn( p ) );
    free( p );

    p = fen_to_pos(
        "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1" );
    ck_assert( !whites_turn( p ) );
    free( p );

//
// Test case
//
#tcase Chessman_enum_tests

#test C_EMPTY_SQUARE_equals_0
    Chessman cm = EMPTY_SQUARE;
    ck_assert( !cm );

#test C_BLACK_PAWN_equals_12
    Chessman cm = BLACK_PAWN;
    ck_assert( cm == 12 );

//
// Test case
//
#tcase sq_set_of_file_tests

#test C_sq_set_of_file_test
    const Bitboard file_a = 0x101010101010101U;
    for( int file = 'a'; file <= 'h'; file++ ) {
        ck_assert( sq_set_of_file( file ) == ( file_a << ( file - 'a' ) ) );
    }

#tcase sq_set_of_rank_tests

#test C_sq_set_of_rank_test
    const Bitboard rank_1 = 0xffU;
    for( int rank = '1'; rank <= '8'; rank++ ) {
        ck_assert( sq_set_of_rank( rank ) ==
            ( rank_1 << ( ( rank - 'a' ) * 8 ) ) );
    }

#tcase SS_DIAG_tests

#test C_SS_DIAG_constants_tested_with_sq_navigator

Bitboard sq_bit = sq_name_to_sq_bit( "h1" ), bb;
int index = 0;
while( true ) {
    bb = 0u;
    char *sq = (char *) sq_bit_to_sq_name( sq_bit );

    do {
        bb |= sq_name_to_sq_bit( sq );
    } while( ( sq = (char *) sq_navigator( sq, NORTHEAST ) ) );
    ck_assert( bb == sq_set_of_diag( index ) );
    ++index;

    if( sq_bit == sq_name_to_sq_bit( "a8" ) )
        break;
    else if( sq_bit < sq_name_to_sq_bit( "a2" ) &&
            sq_bit != sq_name_to_sq_bit( "a1" ) )
        sq_bit >>= 1;
    else
        sq_bit <<= 8;
}

#test C_SS_DIAG_constants_add_up_to_UINT64_MAX
    ck_assert( UINT64_MAX ==
        SS_DIAG_H1H1 + SS_DIAG_G1H2 + SS_DIAG_F1H3 + SS_DIAG_E1H4 + SS_DIAG_D1H5 +
        SS_DIAG_C1H6 + SS_DIAG_B1H7 + SS_DIAG_A1H8 + SS_DIAG_A2G8 + SS_DIAG_A3F8 +
        SS_DIAG_A4E8 + SS_DIAG_A5D8 + SS_DIAG_A6C8 + SS_DIAG_A7B8 + SS_DIAG_A8A8 );

#tcase SS_ANTIDIAG_tests

#test C_SS_ANTIDIAG_constants_tested_with_sq_navigator

Bitboard sq_bit = sq_name_to_sq_bit( "a1" ), bb;
int index = 0;
while( true ) {
    bb = 0u;
    char *sq = (char *) sq_bit_to_sq_name( sq_bit );

    do {
        bb |= sq_name_to_sq_bit( sq );
    } while( ( sq = (char *) sq_navigator( sq, NORTHWEST ) ) );
    ck_assert( bb == sq_set_of_antidiag( index ) );
    ++index;

    if( sq_bit == sq_name_to_sq_bit( "h8" ) )
        break;
    else if( sq_bit < sq_name_to_sq_bit( "h1" ) )
        sq_bit <<= 1;
    else
        sq_bit <<= 8;
}

#test C_SS_ANTIDIAG_constants_add_up_to_UINT64_MAX
    ck_assert( UINT64_MAX ==
        SS_ANTIDIAG_A1A1 + SS_ANTIDIAG_B1A2 + SS_ANTIDIAG_C1A3 +
        SS_ANTIDIAG_D1A4 + SS_ANTIDIAG_E1A5 + SS_ANTIDIAG_F1A6 +
        SS_ANTIDIAG_G1A7 + SS_ANTIDIAG_H1A8 + SS_ANTIDIAG_H2B8 +
        SS_ANTIDIAG_H3C8 + SS_ANTIDIAG_H4D8 + SS_ANTIDIAG_H5E8 +
        SS_ANTIDIAG_H6F8 + SS_ANTIDIAG_H7G8 + SS_ANTIDIAG_H8H8
    );

#tcase sq_set_of_diag_tests

#test C_sq_set_of_diag_comprehensive_input_test
    // ck_assert( sq_set_of_diag( -1 ) == 0 );
    ck_assert( sq_set_of_diag( 0 ) == SB.h1 );
    ck_assert( sq_set_of_diag( 1 ) == ( SB.g1 | SB.h2 ) );
    ck_assert( sq_set_of_diag( 2 ) == ( SB.f1 | SB.g2 | SB.h3 ) );
    ck_assert( sq_set_of_diag( 3 ) == ( SB.e1 | SB.f2 | SB.g3 | SB.h4 ) );
    ck_assert( sq_set_of_diag( 4 ) ==
        ( SB.d1 | SB.e2 | SB.f3 | SB.g4 | SB.h5 ) );
    ck_assert( sq_set_of_diag( 5 ) ==
        ( SB.c1 | SB.d2 | SB.e3 | SB.f4 | SB.g5 | SB.h6 ) );
    ck_assert( sq_set_of_diag( 6 ) ==
        ( SB.b1 | SB.c2 | SB.d3 | SB.e4 | SB.f5 | SB.g6 | SB.h7 ) );
    ck_assert( sq_set_of_diag( 7 ) ==
        ( SB.a1 | SB.b2 | SB.c3 | SB.d4 | SB.e5 | SB.f6 | SB.g7 | SB.h8 ) );
    ck_assert( sq_set_of_diag( 8 ) ==
        ( SB.a2 | SB.b3 | SB.c4 | SB.d5 | SB.e6 | SB.f7 | SB.g8 ) );
    ck_assert( sq_set_of_diag( 9 ) ==
        ( SB.a3 | SB.b4 | SB.c5 | SB.d6 | SB.e7 | SB.f8 ) );
    ck_assert( sq_set_of_diag( 10 ) ==
        ( SB.a4 | SB.b5 | SB.c6 | SB.d7 | SB.e8 ) );
    ck_assert( sq_set_of_diag( 11 ) == ( SB.a5 | SB.b6 | SB.c7 | SB.d8 ) );
    ck_assert( sq_set_of_diag( 12 ) == ( SB.a6 | SB.b7 | SB.c8 ) );
    ck_assert( sq_set_of_diag( 13 ) == ( SB.a7 | SB.b8 ) );
    ck_assert( sq_set_of_diag( 14 ) == SB.a8 );
    // ck_assert( sq_set_of_diag( 15 ) == 0 );

#tcase sq_set_of_antidiag_tests

#test C_sq_set_of_antidiag_comprehensive_input_test
    // ck_assert( sq_set_of_antidiag( -1 ) == 0 );
    ck_assert( sq_set_of_antidiag( 0 ) == SB.a1 );
    ck_assert( sq_set_of_antidiag( 1 ) == ( SB.b1 | SB.a2 ) );
    ck_assert( sq_set_of_antidiag( 2 ) == ( SB.c1 | SB.b2 | SB.a3 ) );
    ck_assert( sq_set_of_antidiag( 3 ) == ( SB.d1 | SB.c2 | SB.b3 | SB.a4 ) );
    ck_assert( sq_set_of_antidiag( 4 ) ==
        ( SB.e1 | SB.d2 | SB.c3 | SB.b4 | SB.a5 ) );
    ck_assert( sq_set_of_antidiag( 5 ) ==
        ( SB.f1 | SB.e2 | SB.d3 | SB.c4 | SB.b5 | SB.a6 ) );
    ck_assert( sq_set_of_antidiag( 6 ) ==
        ( SB.g1 | SB.f2 | SB.e3 | SB.d4 | SB.c5 | SB.b6 | SB.a7 ) );
    ck_assert( sq_set_of_antidiag( 7 ) ==
        ( SB.h1 | SB.g2 | SB.f3 | SB.e4 | SB.d5 | SB.c6 | SB.b7 | SB.a8 ) );
    ck_assert( sq_set_of_antidiag( 8 ) ==
        ( SB.h2 | SB.g3 | SB.f4 | SB.e5 | SB.d6 | SB.c7 | SB.b8 ) );
    ck_assert( sq_set_of_antidiag( 9 ) ==
        ( SB.h3 | SB.g4 | SB.f5 | SB.e6 | SB.d7 | SB.c8 ) );
    ck_assert( sq_set_of_antidiag( 10 ) ==
        ( SB.h4 | SB.g5 | SB.f6 | SB.e7 | SB.d8 ) );
    ck_assert( sq_set_of_antidiag( 11 ) == ( SB.h5 | SB.g6 | SB.f7 | SB.e8 ) );
    ck_assert( sq_set_of_antidiag( 12 ) == ( SB.h6 | SB.g7 | SB.f8 ) );
    ck_assert( sq_set_of_antidiag( 13 ) == ( SB.h7 | SB.g8 ) );
    ck_assert( sq_set_of_antidiag( 14 ) == SB.h8 );
    // ck_assert( sq_set_of_antidiag( 15 ) == 0 );

#tcase ss_white_army_tests

#test C_ss_white_army_std_start_pos
    ck_assert( ss_white_army( fen_to_pos( FEN_STD_START_POS ) ) ==
        0xffffU );

#tcase ss_black_army_tests

#test C_ss_black_army_std_start_pos
    ck_assert( ss_black_army( fen_to_pos( FEN_STD_START_POS ) ) ==
        0xffff000000000000U );

#tcase SQ_NAV_tests

#test C_SQ_NAV_basic_integrity_test
    int num_of_valid_elements = 0, num_of_valid_non_zero_elements = 0;

    for( int i = 0; i < 64; i++ ) {
        for( enum sq_dir d = NORTH; d <= ELEVEN_OCLOCK; d++ ) {
            Bitboard bb = SQ_NAV[ i ][ d ];
            if( !bb || is_sq_bit( bb ) ) {
                ++num_of_valid_elements;
                if( bb )
                    ++num_of_valid_non_zero_elements;

                continue;
            }

            ck_assert( false );
        }
    }

    if( num_of_valid_elements != 1024 || num_of_valid_non_zero_elements != 756 )
        ck_assert( false );

#test C_SQ_NAV_comprehensive_test_with_ALT_sq_navigator
    for( int row = 0; row < 64; row++ ) {
        const char *origin_sq = SNA[ row ];
        for( int col = 0; col < 16; col++ ) {
            const char *sq_in_dir =
                ALT_sq_navigator( origin_sq, (enum sq_dir) col );

            const Bitboard sq_bit = sq_in_dir ? sq_name_to_sq_bit(
                sq_in_dir ) : 0u;
            ck_assert( SQ_NAV[ row ][ col ] == sq_bit );
        }
    }

#test C_SQ_NAV_comprehensive_test_with_KING_SQS_and_KNIGHT_SQS
    for( int row = 0; row < 64; row++ ) {
        Bitboard bb = 0u;
        for( int col = 0; col < 16; col++ ) {
            bb |= SQ_NAV[ row ][ col ];
        }
        ck_assert( bb == ( KING_SQS[ row ] | KNIGHT_SQS[ row ] ) );
    }

#tcase sq_nav_tests

#test C_sq_nav_comprehensive_test_with_KING_SQS_and_KNIGHT_SQS
    for( int i = 0; i < 64; i++ ) {
        Bitboard bb = 0;
        for( int dir = 0; dir < 16; dir++ ) {
            bb |= sq_nav( SBA[ i ], dir );
        }
        ck_assert( bb == ( KING_SQS[ i ] | KNIGHT_SQS[ i ] ) );
    }

//
// Test case
//
#tcase str_array_SHREDDER_FEN_CAFS_tests

#test C_SHREDDER_FEN_CAFS_array_size_test
    int counter = 0;
    for( ; SHREDDER_FEN_CAFS[ counter ]; counter++ ) {}
    ck_assert( counter == (int) SHREDDER_FEN_CAFS_COUNT );

#define N_CHAR_ELEMENTS_COUNT( length, exp_count ) \
int counter = 0; \
for( int i = 0; i < (int) SHREDDER_FEN_CAFS_COUNT; i++ ) \
    if( strlen( SHREDDER_FEN_CAFS[ i ] ) == length ) ++counter; \
ck_assert( counter == exp_count );

// 1c, one-character
#test C_SHREDDER_FEN_CAFS_array_1c_elements_test
    N_CHAR_ELEMENTS_COUNT( 1, 17 ) // "abcdefgh", "ABCDEFGH", "-"

#test C_SHREDDER_FEN_CAFS_array_2c_elements_test
    N_CHAR_ELEMENTS_COUNT( 2, 6 * (int) POSSIBLE_IRPF_VALUES_COUNT + 8 )

#test C_SHREDDER_FEN_CAFS_array_3c_elements_test
    N_CHAR_ELEMENTS_COUNT( 3, 8 * (int) POSSIBLE_IRPF_VALUES_COUNT )

#test C_SHREDDER_FEN_CAFS_array_4c_elements_test
    N_CHAR_ELEMENTS_COUNT( 4, 2 * (int) POSSIBLE_IRPF_VALUES_COUNT )

#undef N_CHAR_ELEMENTS_COUNT

//
// Test case
//
#tcase has_castling_right_tests

// evoc: expected value of call
#define EIGHT_CALL_TEST( value, evoc_1_and_5, evoc_2_and_6, \
        evoc_3_and_7, evoc_4_and_8 ) \
    pos.turn_and_ca_flags = value; \
    ck_assert( \
        has_castling_right( &pos, "white", "kingside" ) == evoc_1_and_5 && \
        has_castling_right( &pos, "white", "queenside" ) == evoc_2_and_6 && \
        has_castling_right( &pos, "black", "kingside" ) == evoc_3_and_7 && \
        has_castling_right( &pos, "black", "queenside" ) == evoc_4_and_8 \
    ); \
    ck_assert( \
        has_castling_right( &pos, "white", "h_side" ) == evoc_1_and_5 && \
        has_castling_right( &pos, "white", "a_side" ) == evoc_2_and_6 && \
        has_castling_right( &pos, "black", "h_side" ) == evoc_3_and_7 && \
        has_castling_right( &pos, "black", "a_side" ) == evoc_4_and_8 \
    );

#test C_has_castling_right_works
    Pos pos;

    EIGHT_CALL_TEST( 0x0fU, true, true, true, true )
    EIGHT_CALL_TEST( 0xf0U, false, false, false, false );
    //     KQkq
    // 10101010 in binary
    EIGHT_CALL_TEST( 0xaaU, true, false, true, false )
    //     KQkq
    // 00001010 in binary
    EIGHT_CALL_TEST( 0x0aU, true, false, true, false )
    //     KQkq
    // 00000101 in binary
    EIGHT_CALL_TEST( 0x05U, false, true, false, true )

    EIGHT_CALL_TEST( 0, false, false, false, false )
    EIGHT_CALL_TEST( 1, false, false, false, true )
    EIGHT_CALL_TEST( 2, false, false, true, false )
    EIGHT_CALL_TEST( 4, false, true, false, false )
    EIGHT_CALL_TEST( 8, true, false, false, false )

#undef EIGHT_CALL_TEST

//
// Test case
//
#tcase epts_tests

#define CREATE_ASSERT_AND_FREE( fen_arg, expected_value ) \
    p = fen_to_pos( fen_arg ); \
    ck_assert( epts(p) == expected_value ); \
    free(p);

#test C_epts_returns_zero
    Pos *p;

    CREATE_ASSERT_AND_FREE(
        FEN_STD_START_POS, 0 )
    CREATE_ASSERT_AND_FREE(
        "nrnqbbkr/pppppppp/8/8/8/8/PPPPPPPP/NRNQBBKR w BHbh - 0 1", 0 )
    CREATE_ASSERT_AND_FREE(
        "nqnrkbbr/pppppppp/8/8/8/8/PPPPPPPP/NQNRKBBR w DHdh - 0 1", 0 )
    CREATE_ASSERT_AND_FREE(
        "rnbk3r/ppp2Bp1/3b1n1p/4p3/4P3/5N2/PPP2PPP/RNB1K2R w KQ - 1 8", 0 )
    CREATE_ASSERT_AND_FREE(
        "rrrrkrrr/pppppppp/pppppppp/pppppppp/PPPPPPPP/PPPPPPPP/PPPPPPPP/RRRRKRRR "
            "w KQkq - 59998 30000", 0 )

#test C_epts_returns_sq_bit
    Pos *p;

    CREATE_ASSERT_AND_FREE(
        "2r1k3/8/8/8/4P3/8/8/4K2R b Hc e3 0 100", SB.e3 )
    CREATE_ASSERT_AND_FREE(
        "rnbqkbnr/pppp1ppp/8/4p3/8/8/PPPPPPPP/RNBQKBNR w KQkq e6 0 1", SB.e6 )
    CREATE_ASSERT_AND_FREE(
        "rnbqkbnr/ppppppp1/8/7p/8/8/PPPPPPPP/RNBQKBNR w KQkq h6 0 1", SB.h6 )
    CREATE_ASSERT_AND_FREE(
        "8/8/8/k7/P7/8/8/K7 b - a3 0 50", SB.a3 )
    CREATE_ASSERT_AND_FREE(
        "8/8/8/7k/7P/8/8/7K b - h3 0 50", SB.h3 )
    CREATE_ASSERT_AND_FREE(
        "k7/8/8/p7/K7/8/8/8 w - a6 0 50", SB.a6 )
    CREATE_ASSERT_AND_FREE(
        "7k/8/8/7p/7K/8/8/8 w - h6 0 50", SB.h6 )

#undef CREATE_ASSERT_AND_FREE

//
// Test case
//
#tcase APM_DATA_tests

#test C_APM_DATA_length_test
    ck_assert( strlen( APM_DATA ) == 4*1792 );

#test C_APM_DATA_valid_characters_test
    int i = 0;
    for( ; APM_DATA[i]; i++ ) {
        char c = APM_DATA[i];
        ck_assert( ( c >= 'a' && c <= 'h' ) || ( c >= '1' && c <= '8' ) );
    }
    ck_assert( i == 4*1792 );

#test C_APM_DATA_has_equal_number_of_letters_and_digits
    int letter_count = 0, digit_count = 0;
    for( int i = 0; APM_DATA[i]; i++ ) {
        char c = APM_DATA[i];

        if( isalpha(c) )
            ++letter_count;
        else if( isdigit(c) )
            ++digit_count;
    }
    ck_assert( letter_count == 2*1792 );
    ck_assert( letter_count == digit_count );

#test C_APM_DATA_compared_to_dynamically_created_duplicate
    char *dup = create_APM_DATA_duplicate();
    ck_assert( !strcmp( APM_DATA, dup ) );
    free(dup);

#test C_APM_DATA_tested_for_ascending_lexiographical_order
    ck_assert( strcmp( "abc", "xyz" ) < 0 );

    char left[4 + 1] = {'\0'}, right[4 + 1] = {'\0'};

    int i = 0, pair_count = 0;
    for( ; i < (int) strlen(APM_DATA) - 4; i += 4 ) {
        for( int j = 0, lindex = i, rindex = i + 4; j < 4; j++ ) {
            left[j]  = APM_DATA[lindex + j];
            right[j] = APM_DATA[rindex + j];
        }
        ++pair_count;

        assert( strlen(left) == 4 );
        assert( strlen(right) == 4);
        assert( str_m_pat( left,  "^[a-h][1-8][a-h][1-8]$" ) );
        assert( str_m_pat( right, "^[a-h][1-8][a-h][1-8]$" ) );

        // printf( "%s  %s\n", left, right );
        ck_assert( strcmp( left, right ) < 0 );
    }

    assert( i + 4 == (int) strlen(APM_DATA) );
    assert( pair_count == (int) (strlen(APM_DATA) / 4) - 1 );
