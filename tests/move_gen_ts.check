#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "../src/move_gen.h"
#include "../src/utils.h"
#include "../src/validation.h"
#include "../src/extra.h"

#suite move_gen_ts

#tcase king_can_be_captured_tests

#test C_king_can_be_captured_returns_true
    // Test FENs moved to
    // #test C_che_fen_str_validator_returns_FEN_*_KING_CAN_BE_CAPTURED
    const char *positions_in_which_king_can_be_captured[] = {
        "Q6k/8/8/8/8/8/8/K7 w - - 0 1",
        NULL };

    for( int i = 0; positions_in_which_king_can_be_captured[ i ]; i++ ) {
        ck_assert( king_can_be_captured( fen_to_pos(
            positions_in_which_king_can_be_captured[ i ] ) ) );
    }

#test C_king_can_be_captured_returns_false
    // Test FENs moved to #test C_che_fen_str_validator_returns_FEN_NO_ERRORS
    const char *positions_in_which_king_cannot_be_captured[] = {
        FEN_STD_START_POS,
        NULL };

    for( int i = 0; positions_in_which_king_cannot_be_captured[ i ]; i++ ) {
        ck_assert( !king_can_be_captured( fen_to_pos(
            positions_in_which_king_cannot_be_captured[ i ] ) ) );
    }

#tcase KNIGHT_SQS_array_tests

#define KNIGHT_SQS_OF_CORNER_SQS_TEST( corner_sq, knight_sq_1, knight_sq_2 ) \
ck_assert( KNIGHT_SQS[ sq_name_index( corner_sq ) ] == \
    ( sq_name_to_sq_bit( knight_sq_1 ) | sq_name_to_sq_bit( knight_sq_2 ) ) );

#define KNIGHT_SQS_OF_CENTER_SQS_TEST( center_sq, ksq1, ksq2, ksq3, ksq4, \
ksq5, ksq6, ksq7, ksq8 ) \
ck_assert( KNIGHT_SQS[ sq_name_index( center_sq ) ] == ( \
    sq_name_to_sq_bit( ksq1 ) | sq_name_to_sq_bit( ksq2 ) | \
    sq_name_to_sq_bit( ksq3 ) | sq_name_to_sq_bit( ksq4 ) | \
    sq_name_to_sq_bit( ksq5 ) | sq_name_to_sq_bit( ksq6 ) | \
    sq_name_to_sq_bit( ksq7 ) | sq_name_to_sq_bit( ksq8 ) ) );

#test C_KNIGHT_SQS_corner_squares_test
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "a1", "c2", "b3" )
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "h1", "f2", "g3" )
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "a8", "b6", "c7" )
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "h8", "g6", "f7" )

#test C_KNIGHT_SQS_center_squares_test
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "d4", "c2", "e2", "b3", "f3", "b5", "f5", "c6", "e6" )
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "e4", "d2", "f2", "c3", "g3", "c5", "g5", "d6", "f6" )
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "d5", "c3", "e3", "b4", "f4", "b6", "f6", "c7", "e7" )
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "e5", "d3", "f3", "c4", "g4", "c6", "g6", "d7", "f7" )

#test C_KNIGHT_SQS_comprehensive_test
    for( int sq_index = 0; sq_index < 64; sq_index++ ) {
        Bitboard sq_bit = SBA[ sq_index ], kerc_of_sq = kerc( sq_bit );

        kerc_of_sq ^= ( kerc_of_sq & sq_set_of_file( file_of_sq( sq_bit ) ) );
        kerc_of_sq ^= ( kerc_of_sq & sq_set_of_rank( rank_of_sq( sq_bit ) ) );
        kerc_of_sq ^= ( kerc_of_sq & diag_of_sq( sq_bit ) );
        kerc_of_sq ^= ( kerc_of_sq & antidiag_of_sq( sq_bit ) );

        ck_assert( KNIGHT_SQS[ sq_index ] == kerc_of_sq );
    }

#tcase kerc_tests

#test C_kerc_edge_squares_test
    ck_assert( kerc( SB.a1 ) == 0x30707U );
    ck_assert( kerc( SB.b1 ) == 0x70f0fU );
    ck_assert( kerc( SB.c1 ) == 0xe1f1fU );
    ck_assert( kerc( SB.d1 ) == 0x1c3e3eU );
    ck_assert( kerc( SB.e1 ) == 0x387c7cU );
    ck_assert( kerc( SB.f1 ) == 0x70f8f8U );
    ck_assert( kerc( SB.g1 ) == 0xe0f0f0U );
    ck_assert( kerc( SB.h1 ) == 0xc0e0e0U );

    ck_assert( kerc( SB.a2 ) == 0x3070707U );
    ck_assert( kerc( SB.a3 ) == 0x307070703U );
    ck_assert( kerc( SB.a4 ) == 0x30707070300U );
    ck_assert( kerc( SB.a5 ) == 0x3070707030000U );
    ck_assert( kerc( SB.a6 ) == 0x307070703000000U );
    ck_assert( kerc( SB.a7 ) == 0x707070300000000U );

    ck_assert( kerc( SB.h2 ) == 0xc0e0e0e0U );
    ck_assert( kerc( SB.h3 ) == 0xc0e0e0e0c0U );
    ck_assert( kerc( SB.h4 ) == 0xc0e0e0e0c000U );
    ck_assert( kerc( SB.h5 ) == 0xc0e0e0e0c00000U );
    ck_assert( kerc( SB.h6 ) == 0xc0e0e0e0c0000000U );
    ck_assert( kerc( SB.h7 ) == 0xe0e0e0c000000000U );

    ck_assert( kerc( SB.a8 ) == 0x707030000000000U );
    ck_assert( kerc( SB.b8 ) == 0xf0f070000000000U );
    ck_assert( kerc( SB.c8 ) == 0x1f1f0e0000000000U );
    ck_assert( kerc( SB.d8 ) == 0x3e3e1c0000000000U );
    ck_assert( kerc( SB.e8 ) == 0x7c7c380000000000U );
    ck_assert( kerc( SB.f8 ) == 0xf8f8700000000000U );
    ck_assert( kerc( SB.g8 ) == 0xf0f0e00000000000U );
    ck_assert( kerc( SB.h8 ) == 0xe0e0c00000000000U );

#test C_kerc_semiedge_squares_test
    ck_assert( kerc( SB.b2 ) == 0x70f0f0fU );
    ck_assert( kerc( SB.c2 ) == 0xe1f1f1fU );
    ck_assert( kerc( SB.d2 ) == 0x1c3e3e3eU );
    ck_assert( kerc( SB.e2 ) == 0x387c7c7cU );
    ck_assert( kerc( SB.f2 ) == 0x70f8f8f8U );
    ck_assert( kerc( SB.g2 ) == 0xe0f0f0f0U );

    ck_assert( kerc( SB.b3 ) == 0x70f0f0f07U );
    ck_assert( kerc( SB.b4 ) == 0x70f0f0f0700U );
    ck_assert( kerc( SB.b5 ) == 0x70f0f0f070000U );
    ck_assert( kerc( SB.b6 ) == 0x70f0f0f07000000U );

    ck_assert( kerc( SB.g3 ) == 0xe0f0f0f0e0U );
    ck_assert( kerc( SB.g4 ) == 0xe0f0f0f0e000U );
    ck_assert( kerc( SB.g5 ) == 0xe0f0f0f0e00000U );
    ck_assert( kerc( SB.g6 ) == 0xe0f0f0f0e0000000U );

    ck_assert( kerc( SB.b7 ) == 0xf0f0f0700000000U );
    ck_assert( kerc( SB.c7 ) == 0x1f1f1f0e00000000U );
    ck_assert( kerc( SB.d7 ) == 0x3e3e3e1c00000000U );
    ck_assert( kerc( SB.e7 ) == 0x7c7c7c3800000000U );
    ck_assert( kerc( SB.f7 ) == 0xf8f8f87000000000U );
    ck_assert( kerc( SB.g7 ) == 0xf0f0f0e000000000U );

#test C_kerc_extended_center_squares_test
    Bitboard kerc_pattern = 0xe1f1f1f0eU, // The KERC of c3
        sq_bit = SB.c3;
    for( int counter = 1; counter <= 16; counter++ ) {
        ck_assert( kerc_pattern == kerc( sq_bit ) );

        if( counter % 4 ) {
            kerc_pattern <<= 1;
            sq_bit <<= 1;
        }
        else {
            kerc_pattern <<= 5;
            sq_bit <<= 5;
        }
    }

#tcase KING_SQS_array_tests

#test C_KING_SQS_non_edge_squares_test
    for( Bitboard sq_bit = SB.b2, king_sqs = 0x70507U; sq_bit <= SB.g7;
            king_sqs <<= ( sq_bit & SS_FILE_G ) ? 3 : 1,
            sq_bit   <<= ( sq_bit & SS_FILE_G ) ? 3 : 1
    ) {
        ck_assert( king_sqs == KING_SQS[ sq_bit_index( sq_bit ) ] );
    }

#test C_KING_SQS_corner_squares_test
    ck_assert( KING_SQS[  0 ] == 0x302U );
    ck_assert( KING_SQS[  7 ] == 0xc040U );
    ck_assert( KING_SQS[ 56 ] == 0x203000000000000U );
    ck_assert( KING_SQS[ 63 ] == 0x40c0000000000000U );

#test C_KING_SQS_edge_squares_test
    Bitboard bb1 = 0x705U, bb2 = 0x507000000000000U;
    for( int i = 1; i <= 6; i++, bb1 <<= 1, bb2 <<= 1 ) {
        ck_assert( KING_SQS[ i ] == bb1 );
        ck_assert( KING_SQS[ i + 56 ] == bb2 );
    }

    bb1 = 0x30203U, bb2 = 0xc040c0U;
    for( int i = 8; i <= 48; i += 8, bb1 <<= 8, bb2 <<= 8 ) {
        ck_assert( KING_SQS[ i ] == bb1 );
        ck_assert( KING_SQS[ i + 7 ] == bb2 );
    }

#tcase ROOK_SQS_array_tests

#test C_ROOK_SQS_center_square_test
    ck_assert( ROOK_SQS[ sq_bit_index( SB.d4 ) ] == 0x8080808f7080808U );
    ck_assert( ROOK_SQS[ sq_bit_index( SB.e4 ) ] == 0x10101010ef101010U );
    ck_assert( ROOK_SQS[ sq_bit_index( SB.d5 ) ] == 0x80808f708080808U );
    ck_assert( ROOK_SQS[ sq_bit_index( SB.e5 ) ] == 0x101010ef10101010U );

#test C_ROOK_SQS_comprehensive_test
    for( int i = 0; i < 64; i++ ) {
        Bitboard bb = 0U;
        const char *sq = SNA[ i ];
        for( enum sq_dir dir = NORTH; dir <= WEST; dir += 2 ) {
            char *current_sq = (char *) sq;
            while( ( current_sq = (char *) sq_navigator( current_sq, dir ) ) ) {
                bb |= sq_name_to_sq_bit( current_sq );
            }
        }
        ck_assert( bb == ROOK_SQS[ i ] );
    }

#tcase BISHOP_SQS_array_tests

#test C_testing_BISHOP_SQS_with_manually_selected_squares
    ck_assert( BISHOP_SQS[ sq_bit_index( SB.a1 ) ] == 0x8040201008040200U );
    ck_assert( BISHOP_SQS[ sq_bit_index( SB.d4 ) ] == 0x8041221400142241U );
    ck_assert( BISHOP_SQS[ sq_bit_index( SB.h8 ) ] == 0x40201008040201U );

#test C_BISHOP_SQS_comprehensive_test
    for( int i = 0; i < 64; i++ ) {
        Bitboard bb = 0U;
        const char *sq = SNA[ i ];
        for( enum sq_dir dir = NORTHEAST; dir <= NORTHWEST; dir += 2 ) {
            char *current_sq = (char *) sq;
            while( ( current_sq = (char *) sq_navigator( current_sq, dir ) ) ) {
                bb |= sq_name_to_sq_bit( current_sq );
            }
        }
        ck_assert( bb == BISHOP_SQS[ i ] );
    }

//
// Test case
//
#tcase attackers_tests

#define INIT_POS_PTR(fen) \
    ck_assert( !che_fen_validator(fen) ); \
    Pos *p = fen_to_pos(fen);

#define TEST_WITH_ARGS( expected_bb, attacked_sq, num_var_arg, ... ) \
    ck_assert( (expected_bb) == \
        attackers( p->ppa, attacked_sq, num_var_arg, __VA_ARGS__ ) );

#test C_attackers_tested_with_kings
    INIT_POS_PTR( "8/8/8/4k3/8/4K3/8/8 w - - 0 100" )

    TEST_WITH_ARGS( SB.e3, SB.e4, 1, WHITE_KING )
    TEST_WITH_ARGS( SB.e5, SB.e4, 1, BLACK_KING )
    TEST_WITH_ARGS( SB.e3 | SB.e5, SB.e4, 2, WHITE_KING, BLACK_KING )
    TEST_WITH_ARGS( SB.e3 | SB.e5, SB.d4, 2, WHITE_KING, BLACK_KING )
    TEST_WITH_ARGS( 0, SB.c4, 2, WHITE_KING, BLACK_KING )
    TEST_WITH_ARGS( SB.e3, SB.e2, 2, WHITE_KING, BLACK_KING )

    free(p);

#test C_attackers_tested_with_rooks
    INIT_POS_PTR( "4r2k/8/8/8/R4rR1/8/4R3/K3R3 w - - 0 100" )

    TEST_WITH_ARGS( SB.e2 | SB.a4, SB.e4, 1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.f4 | SB.e8, SB.e4, 1, BLACK_ROOK )
    TEST_WITH_ARGS( SB.e2 | SB.a4 | SB.f4 | SB.e8,
        SB.e4, 2, WHITE_ROOK, BLACK_ROOK )
    TEST_WITH_ARGS( SB.e2 | SB.a4, SB.a2, 1, WHITE_ROOK )
    TEST_WITH_ARGS( 0, SB.a2, 1, BLACK_ROOK )
    TEST_WITH_ARGS( 0, SB.h3, 2, WHITE_ROOK, BLACK_ROOK )

    free(p);

#test C_attackers_tested_with_queens_1
    INIT_POS_PTR( "3Q4/7k/3q4/8/4q2q/8/3Q4/K2Q4 b - - 0 100" )

    TEST_WITH_ARGS( SB.d2, SB.d4, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.e4 | SB.d6, SB.d4, 1, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.d2 | SB.e4 | SB.d6, SB.d4, 2, WHITE_QUEEN, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.d2 | SB.e4 | SB.d6, SB.d4, 12,
        WHITE_KING, WHITE_QUEEN, WHITE_ROOK,
        WHITE_BISHOP, WHITE_KNIGHT, WHITE_PAWN,
        BLACK_KING, BLACK_QUEEN, BLACK_ROOK,
        BLACK_BISHOP, BLACK_KNIGHT, BLACK_PAWN )
    TEST_WITH_ARGS( 0, SB.a7, 2, WHITE_QUEEN, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.d8, SB.a8, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.e4, SB.a8, 1, BLACK_QUEEN )

    free(p);

#test C_attackers_tested_with_queens_2
    INIT_POS_PTR( "q3Q3/7Q/6q1/k7/1qQ3Qq/3qQ3/2Q1q1q1/2K4Q w - - 10 50" )

    TEST_WITH_ARGS( 0, SB.e4, 6, WHITE_KING, BLACK_KING, WHITE_ROOK,
        BLACK_ROOK, WHITE_BISHOP, BLACK_BISHOP)
    TEST_WITH_ARGS( SB.e3 | SB.c4 | SB.g4 | SB.e8, SB.e4, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.g2 | SB.d3 | SB.g6 | SB.a8, SB.e4, 1, BLACK_QUEEN )
    TEST_WITH_ARGS(
        SB.e3 | SB.c4 | SB.g4 | SB.e8 | SB.g2 | SB.d3 | SB.g6 | SB.a8,
        SB.e4, 2, WHITE_QUEEN, BLACK_QUEEN )
    TEST_WITH_ARGS( 0, SB.a1, 2, WHITE_QUEEN, BLACK_QUEEN )

    free(p);

#test C_attackers_tested_with_bishops
    INIT_POS_PTR( "b3B3/7B/6b1/k7/1bB3Bb/3bB3/2B1b1b1/2K4B w - - 10 50" )

    TEST_WITH_ARGS( SB.c2 | SB.c4, SB.d3, 1, WHITE_BISHOP )
    TEST_WITH_ARGS( SB.e2 | SB.g6, SB.d3, 1, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.c2 | SB.e2 | SB.c4 | SB.g6,
        SB.d3, 2, WHITE_BISHOP, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.e3 | SB.b4, SB.d2, 2, WHITE_BISHOP, BLACK_BISHOP )
    TEST_WITH_ARGS( 0, SB.e5, 2, WHITE_BISHOP, BLACK_BISHOP )

    free(p);

#test C_attackers_tested_with_knights
    INIT_POS_PTR( "7k/8/3n1N2/2N1N1n1/3nnn2/2n1N1N1/3N1n2/K7 b - - 20 60" )

    TEST_WITH_ARGS( SB.d2 | SB.g3 | SB.c5 | SB.f6, SB.e4, 1, WHITE_KNIGHT )
    TEST_WITH_ARGS( SB.f2 | SB.c3 | SB.g5 | SB.d6, SB.e4, 1, BLACK_KNIGHT )
    TEST_WITH_ARGS(
        SB.d2 | SB.g3 | SB.c5 | SB.f6 | SB.f2 | SB.c3 | SB.g5 | SB.d6,
        SB.e4, 2, WHITE_KNIGHT, BLACK_KNIGHT )
    TEST_WITH_ARGS( 0, SB.b2, 2, WHITE_KNIGHT, BLACK_KNIGHT )
    TEST_WITH_ARGS( SB.g3, SB.h1, 1, WHITE_KNIGHT )
    TEST_WITH_ARGS( SB.f2, SB.h1, 1, BLACK_KNIGHT )
    TEST_WITH_ARGS( SB.f2 | SB.g3, SB.h1, 2, WHITE_KNIGHT, BLACK_KNIGHT )

    free(p);

#test C_attackers_tested_with_pawns
    INIT_POS_PTR( "7k/8/8/ppp5/8/PPP5/8/K7 w - - 0 100" )

    TEST_WITH_ARGS( SB.b3 | SB.b5, SB.a4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.a3 | SB.c3 | SB.a5 | SB.c5,
        SB.b4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.b3 | SB.b5, SB.c4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.c3 | SB.c5, SB.d4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( 0, SB.e4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.a3 | SB.c3, SB.b4, 1, WHITE_PAWN )
    TEST_WITH_ARGS( SB.a5 | SB.c5, SB.b4, 1, BLACK_PAWN )

    free(p);

#test C_attackers_tested_with_multiple_types_of_chessmen_1
    INIT_POS_PTR( "q3R3/5P1P/3n1N2/8/1r3k2/3B4/1p2Q1b1/2K5 w - - 0 40" )

    TEST_WITH_ARGS( 0, SB.e4, 1, WHITE_KING )
    TEST_WITH_ARGS( SB.e2, SB.e4, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.e8, SB.e4, 1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.d3, SB.e4, 1, WHITE_BISHOP )
    TEST_WITH_ARGS( SB.f6, SB.e4, 1, WHITE_KNIGHT )
    TEST_WITH_ARGS( 0, SB.e4, 1, WHITE_PAWN )

    TEST_WITH_ARGS( SB.f4, SB.e4, 1, BLACK_KING )
    TEST_WITH_ARGS( SB.a8, SB.e4, 1, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.b4, SB.e4, 1, BLACK_ROOK )
    TEST_WITH_ARGS( SB.g2, SB.e4, 1, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.d6, SB.e4, 1, BLACK_KNIGHT )
    TEST_WITH_ARGS( 0, SB.e4, 1, BLACK_PAWN )

    ck_assert( ( SB.e2 | SB.e8 | SB.d3 | SB.f6 ) ==
        white_attackers( p->ppa, SB.e4 ) );
    ck_assert( ( SB.f4 | SB.a8 | SB.b4 | SB.g2 | SB.d6 ) ==
        black_attackers( p->ppa, SB.e4 ) );

    TEST_WITH_ARGS( SB.b2, SB.c1, 1, BLACK_PAWN )
    TEST_WITH_ARGS( 0, SB.b1, 1, BLACK_PAWN )
    TEST_WITH_ARGS( SB.f7 | SB.h7, SB.g8, 1, WHITE_PAWN )
    TEST_WITH_ARGS( 0, SB.f8, 1, WHITE_PAWN )

    free(p);

#test C_attackers_tested_with_multiple_types_of_chessmen_2
    INIT_POS_PTR( "rk5b/8/8/1b6/8/8/BN6/K1Q5 w - - 10 50" )

    ck_assert( ( SB.c1 | SB.a2 | SB.b2 ) ==
        white_attackers( p->ppa, SB.c4 ) );
    ck_assert( SB.b5 == black_attackers( p->ppa, SB.c4 ) );

    TEST_WITH_ARGS( SB.c1 | SB.a2 | SB.b2 | SB.b5,
        SB.c4, 12,
        WHITE_KING, WHITE_QUEEN, WHITE_ROOK,
        WHITE_BISHOP, WHITE_KNIGHT, WHITE_PAWN,
        BLACK_KING, BLACK_QUEEN, BLACK_ROOK,
        BLACK_BISHOP, BLACK_KNIGHT, BLACK_PAWN )
    TEST_WITH_ARGS( SB.a1 | SB.a8,
        SB.a2, 12,
        WHITE_KING, WHITE_QUEEN, WHITE_ROOK,
        WHITE_BISHOP, WHITE_KNIGHT, WHITE_PAWN,
        BLACK_KING, BLACK_QUEEN, BLACK_ROOK,
        BLACK_BISHOP, BLACK_KNIGHT, BLACK_PAWN )

    free(p);

#test C_attackers_tested_with_multiple_types_of_chessmen_3
    INIT_POS_PTR( "4k3/8/8/8/8/4p3/8/4K2R w K - 10 50" )

    TEST_WITH_ARGS( SB.e1, SB.f1, 1, WHITE_KING )
    TEST_WITH_ARGS( 0, SB.g1, 1, WHITE_KING )
    TEST_WITH_ARGS( SB.e1 | SB.e3, SB.d2, 2, WHITE_KING, BLACK_PAWN )
    TEST_WITH_ARGS( SB.e1, SB.e2, 2, WHITE_KING, BLACK_PAWN )
    TEST_WITH_ARGS( SB.e1 | SB.e3, SB.f2, 2, WHITE_KING, BLACK_PAWN )
    TEST_WITH_ARGS( SB.h1, SB.g1, 1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.h1, SB.h8, 1, WHITE_ROOK )

    free(p);

#undef TEST_WITH_ARGS
#undef INIT_POS_PTR

//
// Test case
//
#tcase castle_tests

#define TEST_WITH_ARGS( fen, side, expected_rawcode, expected_castle_error ) \
    ck_assert( !che_fen_validator(fen) ); \
    p = fen_to_pos(fen); \
    ck_assert( castle(p, side) == expected_rawcode ); \
    ck_assert( castle_error == expected_castle_error ); \
    free(p);

#test castle_returns_zero_and_sets_castle_error_to_CASTLE_NO_CASTLING_RIGHT
    Pos *p;

    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R w Qkq - 10 50", "kingside",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R w Kkq - 10 50", "queenside",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R b KQq - 10 50", "h-side",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R b KQk - 10 50", "a-side",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "8/8/3k4/8/3K4/8/8/8 w - - 0 100", "kingside",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "8/8/3k4/8/3K4/8/8/8 b - - 0 100", "queenside",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "qrkbbrnn/pppppppp/8/8/8/8/PPPPPPPP/QRKBBRNN w Bbf - 0 1",
        "kingside", 0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "qrkbbrnn/pppppppp/8/8/8/8/PPPPPPPP/QRKBBRNN w Fbf - 0 1",
        "queenside", 0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "qrkbbrnn/pppppppp/8/8/8/8/PPPPPPPP/QRKBBRNN b BFb - 0 1",
        "kingside", 0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "qrkbbrnn/pppppppp/8/8/8/8/PPPPPPPP/QRKBBRNN b BFf - 0 1",
        "queenside", 0, CASTLE_NO_CASTLING_RIGHT )

#test castle_returns_zero_and_sets_castle_error_to_CASTLE_KING_IN_CHECK
    Pos *p;

    TEST_WITH_ARGS( "4r1kr/8/8/8/8/8/6R1/6K1 b he - 5 50", "kingside",
        0, CASTLE_KING_IN_CHECK )
    TEST_WITH_ARGS( "4r1kr/8/8/8/8/8/6R1/6K1 b he - 5 50", "queenside",
        0, CASTLE_KING_IN_CHECK )
    TEST_WITH_ARGS( "2k5/8/8/8/8/8/PPPpPPPP/QRKBBRNN w BF - 0 123",
        "kingside", 0, CASTLE_KING_IN_CHECK )
    TEST_WITH_ARGS( "2k5/8/8/8/8/8/PPPpPPPP/QRKBBRNN w BF - 0 123",
        "queenside", 0, CASTLE_KING_IN_CHECK )
    TEST_WITH_ARGS( "2k5/8/q7/8/8/8/8/4RK1R w EH - 0 50",
        "kingside", 0, CASTLE_KING_IN_CHECK )
    TEST_WITH_ARGS( "2k5/8/8/8/8/6n1/8/4RK1R w EH - 0 50",
        "queenside", 0, CASTLE_KING_IN_CHECK )

#test castle_returns_zero_and_sets_castle_error_to_CASTLE_KINGS_PATH_BLOCKED
    Pos *p;

    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/4K1NR w K - 0 100", "kingside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/4KB1R w K - 0 100", "h-side",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( FEN_STD_START_POS, "kingside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( FEN_STD_START_POS, "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "r4Nk1/8/8/8/8/8/8/RRK5 b a - 10 100", "a-side",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "r4rk1/8/8/8/8/8/8/RRK5 b a - 10 100", "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "r3B1k1/8/8/8/8/8/8/RRK5 b a - 10 100", "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "r2q2k1/8/8/8/8/8/8/RRK5 b a - 10 100", "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "r1N3k1/8/8/8/8/8/8/RRK5 b a - 10 100", "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "r1b3k1/8/8/8/8/8/8/RRK5 b a - 10 100", "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "4kr2/8/8/8/8/8/8/4KR1R w K - 5 100", "kingside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "4kr2/8/8/8/8/8/8/4K1RR w K - 5 100", "h-side",
        0, CASTLE_KINGS_PATH_BLOCKED )

#test C_castle_returns_zero_and_sets_CASTLE_KINGS_PATH_IN_CHECK
    Pos *p;
    TEST_WITH_ARGS( "4rk1r/8/8/8/8/8/6R1/6K1 b he - 5 50", "h-side",
        0, CASTLE_KINGS_PATH_IN_CHECK )
    TEST_WITH_ARGS( "r5k1/8/8/8/8/8/5R2/5K2 b a - 0 123", "a-side", // Invert
        0, CASTLE_KINGS_PATH_IN_CHECK )
    TEST_WITH_ARGS( "r5k1/8/2B5/8/8/8/8/5K2 b a - 0 123", "a-side",
        0, CASTLE_KINGS_PATH_IN_CHECK )
    TEST_WITH_ARGS( "r5k1/2P5/8/8/8/8/8/5K2 b a - 0 123", "queenside",
        0, CASTLE_KINGS_PATH_IN_CHECK )

// Rook's path blocked test
    /*
    TEST_WITH_ARGS( "rr4k1/8/8/8/8/8/8/RRK5 b a - 10 100", "queenside",
        rawcode("g8a8"), CASTLE_ROOKS_PATH_BLOCKED )
    */

#test C_castle_returns_920_and_sets_CASTLE_OK
    Pos *p;
    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/4K2R w K - 0 50", "kingside",
        920, CASTLE_OK )
    TEST_WITH_ARGS( "b3k3/6Q1/8/8/8/3NN3/8/4K2R w H - 10 80", "h-side",
        920, CASTLE_OK )

#test C_castle_returns_1576_and_sets_CASTLE_OK
    Pos *p;
    TEST_WITH_ARGS( "r5k1/P7/8/8/8/8/8/5K2 b a - 0 123", "queenside",
        1576, CASTLE_OK )

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase move_info_tests

#define TEST_WITH_ARGS( fen_arg, code_arg, expected_mibs ) \
    ck_assert( !che_fen_validator(fen_arg) ); \
    p = fen_to_pos(fen_arg); \
    ck_assert( move_info(p, code_arg) == (expected_mibs) ); \
    free(p);

#test C_move_info_tested_with_kingside_castling_moves
    Pos *p;
    ck_assert( (MIB_CASTLE | MIB_KINGSIDE) == 3 ); // 3 = 2^1 + 2^0

    TEST_WITH_ARGS( "4k3/8/8/8/8/8/8/4K2R w K - 0 1",
        920, MIB_CASTLE | MIB_KINGSIDE )
    TEST_WITH_ARGS(
        "qrnb1krn/p1p2ppp/1p6/1b1p4/3P4/4P3/PP2NPPP/QR1BBKRN w BGbg - 0 6",
        1160, MIB_CASTLE | MIB_KINGSIDE )
    TEST_WITH_ARGS(
        "r3k2r/8/8/8/4P3/8/8/R3K2R b KQkq e3 0 99",
        1140, MIB_CASTLE | MIB_KINGSIDE )
    TEST_WITH_ARGS(
        "r1bqk2r/2ppbppp/p1n2n2/1p2p3/4P3/1B3N2/PPPP1PPP/RNBQR1K1 b kq - 1 7",
        1140, MIB_CASTLE | MIB_KINGSIDE )

#test C_move_info_tested_with_queenside_castling_moves
    Pos *p;
    ck_assert( MIB_CASTLE == 1 );

    TEST_WITH_ARGS( "4k3/8/8/8/8/8/8/R3K3 w Q - 12 99",
        897, MIB_CASTLE )
    TEST_WITH_ARGS(
        "1r2krbq/p1pp2bp/4p1p1/3nPp2/3P1P2/1N1N2P1/PPP4P/1R2KRBQ w FBfb f6 0 11",
        899, MIB_CASTLE )
    TEST_WITH_ARGS( "r3k2r/8/8/8/4P3/8/8/R3K2R b KQkq e3 0 149",
        1117, MIB_CASTLE )
    TEST_WITH_ARGS( "3rk1r1/P7/8/8/8/8/8/4K1R1 b Gdg - 10 50",
        1125, MIB_CASTLE )

    // printf( "Code: %u\n", rawcode( "e8a8" ) );

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase rawcodes_tests

#define TEST_WITH_ARGS( fen_arg, expected ) \
    ck_assert( !che_fen_validator(fen_arg) ); \
    Pos *p = fen_to_pos(fen_arg); \
    Rawcode *codes = rawcodes(p); \
    ck_assert( !codes[ codes[0] + 1 ] ); \
    ck_assert( expected[0] == codes[0] ); \
    for( int i = 1; i <= codes[0]; i++ ) \
        ck_assert( codes[i] == expected[i] ); \
    free(codes); \
    free(p);

#test C_rawcodes_tested_with_lone_kings
    Rawcode expected[3 + 1];

    expected[ 0] = 3,
    expected[ 1] = rawcode( "h8g7" ),
    expected[ 2] = rawcode( "h8g8" ),
    expected[ 3] = rawcode( "h8h7" );

    TEST_WITH_ARGS( "7k/8/8/8/4K3/8/8/8 b - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_rooks_1
    Rawcode expected[23 + 1];

    expected[ 0] = 23,
    expected[ 1] = rawcode( "a1a2" ),
    expected[ 2] = rawcode( "a1a3" ),
    expected[ 3] = rawcode( "a1a4" ),
    expected[ 4] = rawcode( "a1a5" ),
    expected[ 5] = rawcode( "a1a6" ),
    expected[ 6] = rawcode( "a1a7" ),
    expected[ 7] = rawcode( "a1a8" ),
    expected[ 8] = rawcode( "a1b1" ),
    expected[ 9] = rawcode( "a1c1" ),
    expected[10] = rawcode( "a1d1" ),
    expected[11] = rawcode( "e1a1" ),
    expected[12] = rawcode( "e1d1" ),
    expected[13] = rawcode( "e1f1" ),
    expected[14] = rawcode( "e1h1" ),
    expected[15] = rawcode( "h1f1" ),
    expected[16] = rawcode( "h1g1" ),
    expected[17] = rawcode( "h1h2" ),
    expected[18] = rawcode( "h1h3" ),
    expected[19] = rawcode( "h1h4" ),
    expected[20] = rawcode( "h1h5" ),
    expected[21] = rawcode( "h1h6" ),
    expected[22] = rawcode( "h1h7" ),
    expected[23] = rawcode( "h1h8" );

    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/R3K2R w KQ - 1 100", expected )

#test C_rawcodes_tested_with_kings_and_rooks_2
    Rawcode expected[9 + 1];

    expected[ 0] = 9,
    expected[ 1] = rawcode( "e6d6" ),
    expected[ 2] = rawcode( "e6e1" ),
    expected[ 3] = rawcode( "e6e2" ),
    expected[ 4] = rawcode( "e6e3" ),
    expected[ 5] = rawcode( "e6e4" ),
    expected[ 6] = rawcode( "e6e5" ),
    expected[ 7] = rawcode( "e6f6" ),
    expected[ 8] = rawcode( "e7d6" ),
    expected[ 9] = rawcode( "e7e8" );

    TEST_WITH_ARGS( "8/4k3/3RrR2/6K1/8/8/8/8 b - - 2 34", expected )

#test C_rawcodes_tested_with_kings_and_rooks_3
    Rawcode expected[2 + 1];

    expected[ 0] = 2,
    expected[ 1] = rawcode( "h3h2" ),
    expected[ 2] = rawcode( "h3h4" );

    TEST_WITH_ARGS( "8/8/8/8/7r/7R/r7/5k1K w - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_bishops_1
    Rawcode expected[13 + 1];

    expected[ 0] = 13,
    expected[ 1] = rawcode( "d4a1" ),
    expected[ 2] = rawcode( "d4a7" ),
    expected[ 3] = rawcode( "d4b2" ),
    expected[ 4] = rawcode( "d4b6" ),
    expected[ 5] = rawcode( "d4c3" ),
    expected[ 6] = rawcode( "d4c5" ),
    expected[ 7] = rawcode( "d4e3" ),
    expected[ 8] = rawcode( "d4e5" ),
    expected[ 9] = rawcode( "d4f2" ),
    expected[10] = rawcode( "d4f6" ),
    expected[11] = rawcode( "d4g1" ),
    expected[12] = rawcode( "d4g7" ),
    expected[13] = rawcode( "d4h8" );

    TEST_WITH_ARGS( "8/8/8/8/3B4/6b1/8/5k1K w - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_bishops_2
    Rawcode expected[2 + 1];

    expected[ 0] = 2,
    expected[ 1] = rawcode( "b7c6" ),
    expected[ 2] = rawcode( "b7d5" );

    TEST_WITH_ARGS( "k7/1b6/8/3B4/4K3/8/7B/6B1 b - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_queens_1
    Rawcode expected[27 + 1];

    expected[ 0] = 27,
    expected[ 1] = rawcode( "d4a1" ),
    expected[ 2] = rawcode( "d4a4" ),
    expected[ 3] = rawcode( "d4a7" ),
    expected[ 4] = rawcode( "d4b2" ),
    expected[ 5] = rawcode( "d4b4" ),
    expected[ 6] = rawcode( "d4b6" ),
    expected[ 7] = rawcode( "d4c3" ),
    expected[ 8] = rawcode( "d4c4" ),
    expected[ 9] = rawcode( "d4c5" ),
    expected[10] = rawcode( "d4d1" ),
    expected[11] = rawcode( "d4d2" ),
    expected[12] = rawcode( "d4d3" ),
    expected[13] = rawcode( "d4d5" ),
    expected[14] = rawcode( "d4d6" ),
    expected[15] = rawcode( "d4d7" ),
    expected[16] = rawcode( "d4d8" ),
    expected[17] = rawcode( "d4e3" ),
    expected[18] = rawcode( "d4e4" ),
    expected[19] = rawcode( "d4e5" ),
    expected[20] = rawcode( "d4f2" ),
    expected[21] = rawcode( "d4f4" ),
    expected[22] = rawcode( "d4f6" ),
    expected[23] = rawcode( "d4g1" ),
    expected[24] = rawcode( "d4g4" ),
    expected[25] = rawcode( "d4g7" ),
    expected[26] = rawcode( "d4h4" ),
    expected[27] = rawcode( "d4h8" );

    TEST_WITH_ARGS( "k1K5/4q3/8/8/3Q4/8/8/8 w - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_queens_2
    Rawcode expected[7 + 1];

    expected[ 0] = 7,
    expected[ 1] = rawcode( "h1g1" ),
    expected[ 2] = rawcode( "h1g2" ),
    expected[ 3] = rawcode( "h1h2" ),
    expected[ 4] = rawcode( "h1h3" ),
    expected[ 5] = rawcode( "h1h4" ),
    expected[ 6] = rawcode( "h1h5" ),
    expected[ 7] = rawcode( "h6g6" );

    TEST_WITH_ARGS( "7K/8/7k/Q7/8/6p1/6Q1/6Qq b - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_knights_1
    Rawcode expected[3 + 1];

    expected[ 0] = 3,
    expected[ 1] = rawcode( "b1a3" ),
    expected[ 2] = rawcode( "b1c3" ),
    expected[ 3] = rawcode( "b1d2" );

    TEST_WITH_ARGS( "8/8/8/8/8/1k6/8/KN6 w - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_knights_2
    Rawcode expected[6 + 1];

    expected[ 0] = 6,
    expected[ 1] = rawcode( "a1a2" ),
    expected[ 2] = rawcode( "e2c3" ),
    expected[ 3] = rawcode( "e2d4" ),
    expected[ 4] = rawcode( "e2f4" ),
    expected[ 5] = rawcode( "e2g1" ),
    expected[ 6] = rawcode( "e2g3" );

    TEST_WITH_ARGS( "1R5K/8/8/8/8/8/4n3/k1n3R1 b - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_pawns_1
    Rawcode expected[2 + 1];

    expected[ 0] = 2,
    expected[ 1] = rawcode( "h2h3" ),
    expected[ 2] = rawcode( "h2h4" );

    TEST_WITH_ARGS( "8/8/8/8/8/8/7P/5k1K w - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_pawns_2
    Rawcode expected[2 + 1];

    expected[ 0] = 2,
    expected[ 1] = rawcode( "e7e5" ),
    expected[ 2] = rawcode( "e7e6" );

    TEST_WITH_ARGS( "1k6/1P2p3/1K6/8/8/8/8/8 b - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_pawns_3
    Rawcode expected[3 + 1];

    expected[ 0] = 3,
    expected[ 1] = rawcode( "e1f1" ),
    expected[ 2] = rawcode( "e2d3" );
    expected[ 3] = rawcode( "e2f3" );

    TEST_WITH_ARGS( "8/8/8/8/8/3qkp2/4P3/4K3 w - - 0 1", expected )

#test C_rawcodes_tested_with_kings_and_pawns_4
    Rawcode expected[3 + 1];

    expected[ 0] = 3,
    expected[ 1] = rawcode( "d2c1" ),
    expected[ 2] = rawcode( "d2d1" );
    expected[ 3] = rawcode( "d2e1" );

    TEST_WITH_ARGS( "8/8/8/8/1Q6/3k4/1K1p4/2B1R3 b - - 0 1", expected )

#test C_rawcodes_tested_with_stalemate_positions
    Rawcode expected[0 + 1];

    expected[0] = 0;

    TEST_WITH_ARGS( "8/8/3p4/3R4/4k3/3R4/4p2B/4K3 b - - 0 99", expected )
    // TODO: Assert that the king is not in check

#test C_rawcodes_tested_with_game_of_the_century_after_11_Bg5
    Rawcode expected[37 + 1];

    expected[ 0] = 37,
    expected[ 1] = rawcode( "a7a5" ),
    expected[ 2] = rawcode( "a7a6" ),
    expected[ 3] = rawcode( "a8b8" ),
    expected[ 4] = rawcode( "a8c8" ),
    expected[ 5] = rawcode( "b6a4" ),
    expected[ 6] = rawcode( "b6c4" ),
    expected[ 7] = rawcode( "b6c8" ),
    expected[ 8] = rawcode( "b6d5" ),
    expected[ 9] = rawcode( "b6d7" ),
    expected[10] = rawcode( "d8b8" ),
    expected[11] = rawcode( "d8c7" ),
    expected[12] = rawcode( "d8c8" ),
    expected[13] = rawcode( "d8d4" ),
    expected[14] = rawcode( "d8d5" ),
    expected[15] = rawcode( "d8d6" ),
    expected[16] = rawcode( "d8d7" ),
    expected[17] = rawcode( "d8e8" ),
    expected[18] = rawcode( "e7e5" ),
    expected[19] = rawcode( "e7e6" ),
    expected[20] = rawcode( "f6d5" ),
    expected[21] = rawcode( "f6d7" ),
    expected[22] = rawcode( "f6e4" ),
    expected[23] = rawcode( "f6e8" ),
    expected[24] = rawcode( "f6h5" ),
    expected[25] = rawcode( "f8e8" ),
    expected[26] = rawcode( "g4c8" ),
    expected[27] = rawcode( "g4d7" ),
    expected[28] = rawcode( "g4e6" ),
    expected[29] = rawcode( "g4f3" ),
    expected[30] = rawcode( "g4f5" ),
    expected[31] = rawcode( "g4h3" ),
    expected[32] = rawcode( "g4h5" ),
    expected[33] = rawcode( "g7h6" ),
    expected[34] = rawcode( "g7h8" ),
    expected[35] = rawcode( "g8h8" ),
    expected[36] = rawcode( "h7h5" ),
    expected[37] = rawcode( "h7h6" );

    TEST_WITH_ARGS( FEN_GAME_OF_THE_CENTURY, expected )

#test C_rawcodes_tested_with_marshall_attack_position
    Rawcode expected[26 + 1];

    expected[ 0] = 26,
    expected[ 1] = rawcode( "a2a3" ),
    expected[ 2] = rawcode( "a2a4" ),
    expected[ 3] = rawcode( "b1a3" ),
    expected[ 4] = rawcode( "b3a4" ),
    expected[ 5] = rawcode( "b3c2" ),
    expected[ 6] = rawcode( "b3c4" ),
    expected[ 7] = rawcode( "b3d5" ),
    expected[ 8] = rawcode( "c3c4" ),
    expected[ 9] = rawcode( "d1c2" ),
    expected[10] = rawcode( "d1e2" ),
    expected[11] = rawcode( "d2d3" ),
    expected[12] = rawcode( "d2d4" ),
    expected[13] = rawcode( "e1e2" ),
    expected[14] = rawcode( "e1e3" ),
    expected[15] = rawcode( "e1f1" ),
    expected[16] = rawcode( "e4d5" ),
    expected[17] = rawcode( "f3d4" ),
    expected[18] = rawcode( "f3e5" ),
    expected[19] = rawcode( "f3g5" ),
    expected[20] = rawcode( "f3h4" ),
    expected[21] = rawcode( "g1f1" ),
    expected[22] = rawcode( "g1h1" ),
    expected[23] = rawcode( "g2g3" ),
    expected[24] = rawcode( "g2g4" ),
    expected[25] = rawcode( "h2h3" ),
    expected[26] = rawcode( "h2h4" );

    TEST_WITH_ARGS(
        "r1bq1rk1/2p1bppp/p1n2n2/1p1pp3/4P3/1BP2N2/PP1P1PPP/RNBQR1K1 w - - 0 9",
        expected )

#undef TEST_WITH_ARGS
