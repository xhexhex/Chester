#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "../src/move_gen.h"
#include "../src/utils.h"
#include "../src/validation.h"
#include "../src/extra.h"

#suite move_gen_ts

#tcase king_can_be_captured_tests

#test C_king_can_be_captured_returns_true
    // Test FENs moved to
    // #test C_che_fen_str_validator_returns_FEN_*_KING_CAN_BE_CAPTURED
    const char *positions_in_which_king_can_be_captured[] = {
        "Q6k/8/8/8/8/8/8/K7 w - - 0 1",
        NULL };

    for( int i = 0; positions_in_which_king_can_be_captured[ i ]; i++ ) {
        ck_assert( king_can_be_captured( fen_to_pos(
            positions_in_which_king_can_be_captured[ i ] ) ) );
    }

#test C_king_can_be_captured_returns_false
    // Test FENs moved to #test C_che_fen_str_validator_returns_FEN_NO_ERRORS
    const char *positions_in_which_king_cannot_be_captured[] = {
        FEN_STD_START_POS,
        NULL };

    for( int i = 0; positions_in_which_king_cannot_be_captured[ i ]; i++ ) {
        ck_assert( !king_can_be_captured( fen_to_pos(
            positions_in_which_king_cannot_be_captured[ i ] ) ) );
    }

#tcase KNIGHT_SQS_array_tests

#define KNIGHT_SQS_OF_CORNER_SQS_TEST( corner_sq, knight_sq_1, knight_sq_2 ) \
ck_assert( KNIGHT_SQS[ sq_name_index( corner_sq ) ] == \
    ( sq_name_to_sq_bit( knight_sq_1 ) | sq_name_to_sq_bit( knight_sq_2 ) ) );

#define KNIGHT_SQS_OF_CENTER_SQS_TEST( center_sq, ksq1, ksq2, ksq3, ksq4, \
ksq5, ksq6, ksq7, ksq8 ) \
ck_assert( KNIGHT_SQS[ sq_name_index( center_sq ) ] == ( \
    sq_name_to_sq_bit( ksq1 ) | sq_name_to_sq_bit( ksq2 ) | \
    sq_name_to_sq_bit( ksq3 ) | sq_name_to_sq_bit( ksq4 ) | \
    sq_name_to_sq_bit( ksq5 ) | sq_name_to_sq_bit( ksq6 ) | \
    sq_name_to_sq_bit( ksq7 ) | sq_name_to_sq_bit( ksq8 ) ) );

#test C_KNIGHT_SQS_corner_squares_test
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "a1", "c2", "b3" )
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "h1", "f2", "g3" )
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "a8", "b6", "c7" )
    KNIGHT_SQS_OF_CORNER_SQS_TEST( "h8", "g6", "f7" )

#test C_KNIGHT_SQS_center_squares_test
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "d4", "c2", "e2", "b3", "f3", "b5", "f5", "c6", "e6" )
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "e4", "d2", "f2", "c3", "g3", "c5", "g5", "d6", "f6" )
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "d5", "c3", "e3", "b4", "f4", "b6", "f6", "c7", "e7" )
    KNIGHT_SQS_OF_CENTER_SQS_TEST(
        "e5", "d3", "f3", "c4", "g4", "c6", "g6", "d7", "f7" )

#test C_KNIGHT_SQS_comprehensive_test
    for( int sq_index = 0; sq_index < 64; sq_index++ ) {
        Bitboard sq_bit = SBA[ sq_index ], kerc_of_sq = kerc( sq_bit );

        kerc_of_sq ^= ( kerc_of_sq & sq_set_of_file( file_of_sq( sq_bit ) ) );
        kerc_of_sq ^= ( kerc_of_sq & sq_set_of_rank( rank_of_sq( sq_bit ) ) );
        kerc_of_sq ^= ( kerc_of_sq & diag_of_sq( sq_bit ) );
        kerc_of_sq ^= ( kerc_of_sq & antidiag_of_sq( sq_bit ) );

        ck_assert( KNIGHT_SQS[ sq_index ] == kerc_of_sq );
    }

#tcase kerc_tests

#test C_kerc_edge_squares_test
    ck_assert( kerc( SB.a1 ) == 0x30707U );
    ck_assert( kerc( SB.b1 ) == 0x70f0fU );
    ck_assert( kerc( SB.c1 ) == 0xe1f1fU );
    ck_assert( kerc( SB.d1 ) == 0x1c3e3eU );
    ck_assert( kerc( SB.e1 ) == 0x387c7cU );
    ck_assert( kerc( SB.f1 ) == 0x70f8f8U );
    ck_assert( kerc( SB.g1 ) == 0xe0f0f0U );
    ck_assert( kerc( SB.h1 ) == 0xc0e0e0U );

    ck_assert( kerc( SB.a2 ) == 0x3070707U );
    ck_assert( kerc( SB.a3 ) == 0x307070703U );
    ck_assert( kerc( SB.a4 ) == 0x30707070300U );
    ck_assert( kerc( SB.a5 ) == 0x3070707030000U );
    ck_assert( kerc( SB.a6 ) == 0x307070703000000U );
    ck_assert( kerc( SB.a7 ) == 0x707070300000000U );

    ck_assert( kerc( SB.h2 ) == 0xc0e0e0e0U );
    ck_assert( kerc( SB.h3 ) == 0xc0e0e0e0c0U );
    ck_assert( kerc( SB.h4 ) == 0xc0e0e0e0c000U );
    ck_assert( kerc( SB.h5 ) == 0xc0e0e0e0c00000U );
    ck_assert( kerc( SB.h6 ) == 0xc0e0e0e0c0000000U );
    ck_assert( kerc( SB.h7 ) == 0xe0e0e0c000000000U );

    ck_assert( kerc( SB.a8 ) == 0x707030000000000U );
    ck_assert( kerc( SB.b8 ) == 0xf0f070000000000U );
    ck_assert( kerc( SB.c8 ) == 0x1f1f0e0000000000U );
    ck_assert( kerc( SB.d8 ) == 0x3e3e1c0000000000U );
    ck_assert( kerc( SB.e8 ) == 0x7c7c380000000000U );
    ck_assert( kerc( SB.f8 ) == 0xf8f8700000000000U );
    ck_assert( kerc( SB.g8 ) == 0xf0f0e00000000000U );
    ck_assert( kerc( SB.h8 ) == 0xe0e0c00000000000U );

#test C_kerc_semiedge_squares_test
    ck_assert( kerc( SB.b2 ) == 0x70f0f0fU );
    ck_assert( kerc( SB.c2 ) == 0xe1f1f1fU );
    ck_assert( kerc( SB.d2 ) == 0x1c3e3e3eU );
    ck_assert( kerc( SB.e2 ) == 0x387c7c7cU );
    ck_assert( kerc( SB.f2 ) == 0x70f8f8f8U );
    ck_assert( kerc( SB.g2 ) == 0xe0f0f0f0U );

    ck_assert( kerc( SB.b3 ) == 0x70f0f0f07U );
    ck_assert( kerc( SB.b4 ) == 0x70f0f0f0700U );
    ck_assert( kerc( SB.b5 ) == 0x70f0f0f070000U );
    ck_assert( kerc( SB.b6 ) == 0x70f0f0f07000000U );

    ck_assert( kerc( SB.g3 ) == 0xe0f0f0f0e0U );
    ck_assert( kerc( SB.g4 ) == 0xe0f0f0f0e000U );
    ck_assert( kerc( SB.g5 ) == 0xe0f0f0f0e00000U );
    ck_assert( kerc( SB.g6 ) == 0xe0f0f0f0e0000000U );

    ck_assert( kerc( SB.b7 ) == 0xf0f0f0700000000U );
    ck_assert( kerc( SB.c7 ) == 0x1f1f1f0e00000000U );
    ck_assert( kerc( SB.d7 ) == 0x3e3e3e1c00000000U );
    ck_assert( kerc( SB.e7 ) == 0x7c7c7c3800000000U );
    ck_assert( kerc( SB.f7 ) == 0xf8f8f87000000000U );
    ck_assert( kerc( SB.g7 ) == 0xf0f0f0e000000000U );

#test C_kerc_extended_center_squares_test
    Bitboard kerc_pattern = 0xe1f1f1f0eU, // The KERC of c3
        sq_bit = SB.c3;
    for( int counter = 1; counter <= 16; counter++ ) {
        ck_assert( kerc_pattern == kerc( sq_bit ) );

        if( counter % 4 ) {
            kerc_pattern <<= 1;
            sq_bit <<= 1;
        }
        else {
            kerc_pattern <<= 5;
            sq_bit <<= 5;
        }
    }

#tcase KING_SQS_array_tests

#test C_KING_SQS_non_edge_squares_test
    for( Bitboard sq_bit = SB.b2, king_sqs = 0x70507U; sq_bit <= SB.g7;
            king_sqs <<= ( sq_bit & SS_FILE_G ) ? 3 : 1,
            sq_bit   <<= ( sq_bit & SS_FILE_G ) ? 3 : 1
    ) {
        ck_assert( king_sqs == KING_SQS[ sq_bit_index( sq_bit ) ] );
    }

#test C_KING_SQS_corner_squares_test
    ck_assert( KING_SQS[  0 ] == 0x302U );
    ck_assert( KING_SQS[  7 ] == 0xc040U );
    ck_assert( KING_SQS[ 56 ] == 0x203000000000000U );
    ck_assert( KING_SQS[ 63 ] == 0x40c0000000000000U );

#test C_KING_SQS_edge_squares_test
    Bitboard bb1 = 0x705U, bb2 = 0x507000000000000U;
    for( int i = 1; i <= 6; i++, bb1 <<= 1, bb2 <<= 1 ) {
        ck_assert( KING_SQS[ i ] == bb1 );
        ck_assert( KING_SQS[ i + 56 ] == bb2 );
    }

    bb1 = 0x30203U, bb2 = 0xc040c0U;
    for( int i = 8; i <= 48; i += 8, bb1 <<= 8, bb2 <<= 8 ) {
        ck_assert( KING_SQS[ i ] == bb1 );
        ck_assert( KING_SQS[ i + 7 ] == bb2 );
    }

#tcase ROOK_SQS_array_tests

#test C_ROOK_SQS_center_square_test
    ck_assert( ROOK_SQS[ sq_bit_index( SB.d4 ) ] == 0x8080808f7080808U );
    ck_assert( ROOK_SQS[ sq_bit_index( SB.e4 ) ] == 0x10101010ef101010U );
    ck_assert( ROOK_SQS[ sq_bit_index( SB.d5 ) ] == 0x80808f708080808U );
    ck_assert( ROOK_SQS[ sq_bit_index( SB.e5 ) ] == 0x101010ef10101010U );

#test C_ROOK_SQS_comprehensive_test
    for( int i = 0; i < 64; i++ ) {
        Bitboard bb = 0U;
        const char *sq = SNA[ i ];
        for( enum sq_dir dir = NORTH; dir <= WEST; dir += 2 ) {
            char *current_sq = (char *) sq;
            while( ( current_sq = (char *) sq_navigator( current_sq, dir ) ) ) {
                bb |= sq_name_to_sq_bit( current_sq );
            }
        }
        ck_assert( bb == ROOK_SQS[ i ] );
    }

#tcase BISHOP_SQS_array_tests

#test C_testing_BISHOP_SQS_with_manually_selected_squares
    ck_assert( BISHOP_SQS[ sq_bit_index( SB.a1 ) ] == 0x8040201008040200U );
    ck_assert( BISHOP_SQS[ sq_bit_index( SB.d4 ) ] == 0x8041221400142241U );
    ck_assert( BISHOP_SQS[ sq_bit_index( SB.h8 ) ] == 0x40201008040201U );

#test C_BISHOP_SQS_comprehensive_test
    for( int i = 0; i < 64; i++ ) {
        Bitboard bb = 0U;
        const char *sq = SNA[ i ];
        for( enum sq_dir dir = NORTHEAST; dir <= NORTHWEST; dir += 2 ) {
            char *current_sq = (char *) sq;
            while( ( current_sq = (char *) sq_navigator( current_sq, dir ) ) ) {
                bb |= sq_name_to_sq_bit( current_sq );
            }
        }
        ck_assert( bb == BISHOP_SQS[ i ] );
    }

//
// Test case
//
#tcase attackers_tests

#define INIT_POS_PTR(fen) \
    ck_assert( !che_fen_validator(fen) ); \
    Pos *p = fen_to_pos(fen);

#define TEST_WITH_ARGS( expected_bb, attacked_sq, num_var_arg, ... ) \
    ck_assert( (expected_bb) == \
        attackers( p->ppa, attacked_sq, num_var_arg, __VA_ARGS__ ) );

#test C_attackers_tested_with_kings
    INIT_POS_PTR( "8/8/8/4k3/8/4K3/8/8 w - - 0 100" )

    TEST_WITH_ARGS( SB.e3, SB.e4, 1, WHITE_KING )
    TEST_WITH_ARGS( SB.e5, SB.e4, 1, BLACK_KING )
    TEST_WITH_ARGS( SB.e3 | SB.e5, SB.e4, 2, WHITE_KING, BLACK_KING )
    TEST_WITH_ARGS( SB.e3 | SB.e5, SB.d4, 2, WHITE_KING, BLACK_KING )
    TEST_WITH_ARGS( 0, SB.c4, 2, WHITE_KING, BLACK_KING )
    TEST_WITH_ARGS( SB.e3, SB.e2, 2, WHITE_KING, BLACK_KING )

    free(p);

#test C_attackers_tested_with_rooks
    INIT_POS_PTR( "4r2k/8/8/8/R4rR1/8/4R3/K3R3 w - - 0 100" )

    TEST_WITH_ARGS( SB.e2 | SB.a4, SB.e4, 1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.f4 | SB.e8, SB.e4, 1, BLACK_ROOK )
    TEST_WITH_ARGS( SB.e2 | SB.a4 | SB.f4 | SB.e8,
        SB.e4, 2, WHITE_ROOK, BLACK_ROOK )
    TEST_WITH_ARGS( SB.e2 | SB.a4, SB.a2, 1, WHITE_ROOK )
    TEST_WITH_ARGS( 0, SB.a2, 1, BLACK_ROOK )
    TEST_WITH_ARGS( 0, SB.h3, 2, WHITE_ROOK, BLACK_ROOK )

    free(p);

#test C_attackers_tested_with_queens_1
    INIT_POS_PTR( "3Q4/7k/3q4/8/4q2q/8/3Q4/K2Q4 b - - 0 100" )

    TEST_WITH_ARGS( SB.d2, SB.d4, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.e4 | SB.d6, SB.d4, 1, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.d2 | SB.e4 | SB.d6, SB.d4, 2, WHITE_QUEEN, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.d2 | SB.e4 | SB.d6, SB.d4, 12,
        WHITE_KING, WHITE_QUEEN, WHITE_ROOK,
        WHITE_BISHOP, WHITE_KNIGHT, WHITE_PAWN,
        BLACK_KING, BLACK_QUEEN, BLACK_ROOK,
        BLACK_BISHOP, BLACK_KNIGHT, BLACK_PAWN )
    TEST_WITH_ARGS( 0, SB.a7, 2, WHITE_QUEEN, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.d8, SB.a8, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.e4, SB.a8, 1, BLACK_QUEEN )

    free(p);

#test C_attackers_tested_with_queens_2
    INIT_POS_PTR( "q3Q3/7Q/6q1/k7/1qQ3Qq/3qQ3/2Q1q1q1/2K4Q w - - 10 50" )

    TEST_WITH_ARGS( 0, SB.e4, 6, WHITE_KING, BLACK_KING, WHITE_ROOK,
        BLACK_ROOK, WHITE_BISHOP, BLACK_BISHOP)
    TEST_WITH_ARGS( SB.e3 | SB.c4 | SB.g4 | SB.e8, SB.e4, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.g2 | SB.d3 | SB.g6 | SB.a8, SB.e4, 1, BLACK_QUEEN )
    TEST_WITH_ARGS(
        SB.e3 | SB.c4 | SB.g4 | SB.e8 | SB.g2 | SB.d3 | SB.g6 | SB.a8,
        SB.e4, 2, WHITE_QUEEN, BLACK_QUEEN )
    TEST_WITH_ARGS( 0, SB.a1, 2, WHITE_QUEEN, BLACK_QUEEN )

    free(p);

#test C_attackers_tested_with_bishops
    INIT_POS_PTR( "b3B3/7B/6b1/k7/1bB3Bb/3bB3/2B1b1b1/2K4B w - - 10 50" )

    TEST_WITH_ARGS( SB.c2 | SB.c4, SB.d3, 1, WHITE_BISHOP )
    TEST_WITH_ARGS( SB.e2 | SB.g6, SB.d3, 1, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.c2 | SB.e2 | SB.c4 | SB.g6,
        SB.d3, 2, WHITE_BISHOP, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.e3 | SB.b4, SB.d2, 2, WHITE_BISHOP, BLACK_BISHOP )
    TEST_WITH_ARGS( 0, SB.e5, 2, WHITE_BISHOP, BLACK_BISHOP )

    free(p);

#test C_attackers_tested_with_knights
    INIT_POS_PTR( "7k/8/3n1N2/2N1N1n1/3nnn2/2n1N1N1/3N1n2/K7 b - - 20 60" )

    TEST_WITH_ARGS( SB.d2 | SB.g3 | SB.c5 | SB.f6, SB.e4, 1, WHITE_KNIGHT )
    TEST_WITH_ARGS( SB.f2 | SB.c3 | SB.g5 | SB.d6, SB.e4, 1, BLACK_KNIGHT )
    TEST_WITH_ARGS(
        SB.d2 | SB.g3 | SB.c5 | SB.f6 | SB.f2 | SB.c3 | SB.g5 | SB.d6,
        SB.e4, 2, WHITE_KNIGHT, BLACK_KNIGHT )
    TEST_WITH_ARGS( 0, SB.b2, 2, WHITE_KNIGHT, BLACK_KNIGHT )
    TEST_WITH_ARGS( SB.g3, SB.h1, 1, WHITE_KNIGHT )
    TEST_WITH_ARGS( SB.f2, SB.h1, 1, BLACK_KNIGHT )
    TEST_WITH_ARGS( SB.f2 | SB.g3, SB.h1, 2, WHITE_KNIGHT, BLACK_KNIGHT )

    free(p);

#test C_attackers_tested_with_pawns
    INIT_POS_PTR( "7k/8/8/ppp5/8/PPP5/8/K7 w - - 0 100" )

    TEST_WITH_ARGS( SB.b3 | SB.b5, SB.a4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.a3 | SB.c3 | SB.a5 | SB.c5,
        SB.b4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.b3 | SB.b5, SB.c4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.c3 | SB.c5, SB.d4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( 0, SB.e4, 2, WHITE_PAWN, BLACK_PAWN )
    TEST_WITH_ARGS( SB.a3 | SB.c3, SB.b4, 1, WHITE_PAWN )
    TEST_WITH_ARGS( SB.a5 | SB.c5, SB.b4, 1, BLACK_PAWN )

    free(p);

#test C_attackers_tested_with_multiple_types_of_chessmen_1
    INIT_POS_PTR( "q3R3/5P1P/3n1N2/8/1r3k2/3B4/1p2Q1b1/2K5 w - - 0 40" )

    TEST_WITH_ARGS( 0, SB.e4, 1, WHITE_KING )
    TEST_WITH_ARGS( SB.e2, SB.e4, 1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.e8, SB.e4, 1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.d3, SB.e4, 1, WHITE_BISHOP )
    TEST_WITH_ARGS( SB.f6, SB.e4, 1, WHITE_KNIGHT )
    TEST_WITH_ARGS( 0, SB.e4, 1, WHITE_PAWN )

    TEST_WITH_ARGS( SB.f4, SB.e4, 1, BLACK_KING )
    TEST_WITH_ARGS( SB.a8, SB.e4, 1, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.b4, SB.e4, 1, BLACK_ROOK )
    TEST_WITH_ARGS( SB.g2, SB.e4, 1, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.d6, SB.e4, 1, BLACK_KNIGHT )
    TEST_WITH_ARGS( 0, SB.e4, 1, BLACK_PAWN )

    ck_assert( ( SB.e2 | SB.e8 | SB.d3 | SB.f6 ) ==
        white_attackers( p->ppa, SB.e4 ) );
    ck_assert( ( SB.f4 | SB.a8 | SB.b4 | SB.g2 | SB.d6 ) ==
        black_attackers( p->ppa, SB.e4 ) );

    TEST_WITH_ARGS( SB.b2, SB.c1, 1, BLACK_PAWN )
    TEST_WITH_ARGS( 0, SB.b1, 1, BLACK_PAWN )
    TEST_WITH_ARGS( SB.f7 | SB.h7, SB.g8, 1, WHITE_PAWN )
    TEST_WITH_ARGS( 0, SB.f8, 1, WHITE_PAWN )

    free(p);

#test C_attackers_tested_with_multiple_types_of_chessmen_2
    INIT_POS_PTR( "rk5b/8/8/1b6/8/8/BN6/K1Q5 w - - 10 50" )

    ck_assert( ( SB.c1 | SB.a2 | SB.b2 ) ==
        white_attackers( p->ppa, SB.c4 ) );
    ck_assert( SB.b5 == black_attackers( p->ppa, SB.c4 ) );

    TEST_WITH_ARGS( SB.c1 | SB.a2 | SB.b2 | SB.b5,
        SB.c4, 12,
        WHITE_KING, WHITE_QUEEN, WHITE_ROOK,
        WHITE_BISHOP, WHITE_KNIGHT, WHITE_PAWN,
        BLACK_KING, BLACK_QUEEN, BLACK_ROOK,
        BLACK_BISHOP, BLACK_KNIGHT, BLACK_PAWN )
    TEST_WITH_ARGS( SB.a1 | SB.a8,
        SB.a2, 12,
        WHITE_KING, WHITE_QUEEN, WHITE_ROOK,
        WHITE_BISHOP, WHITE_KNIGHT, WHITE_PAWN,
        BLACK_KING, BLACK_QUEEN, BLACK_ROOK,
        BLACK_BISHOP, BLACK_KNIGHT, BLACK_PAWN )

    free(p);

#test C_attackers_tested_with_multiple_types_of_chessmen_3
    INIT_POS_PTR( "4k3/8/8/8/8/4p3/8/4K2R w K - 10 50" )

    TEST_WITH_ARGS( SB.e1, SB.f1, 1, WHITE_KING )
    TEST_WITH_ARGS( 0, SB.g1, 1, WHITE_KING )
    TEST_WITH_ARGS( SB.e1 | SB.e3, SB.d2, 2, WHITE_KING, BLACK_PAWN )
    TEST_WITH_ARGS( SB.e1, SB.e2, 2, WHITE_KING, BLACK_PAWN )
    TEST_WITH_ARGS( SB.e1 | SB.e3, SB.f2, 2, WHITE_KING, BLACK_PAWN )
    TEST_WITH_ARGS( SB.h1, SB.g1, 1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.h1, SB.h8, 1, WHITE_ROOK )

    free(p);

#undef TEST_WITH_ARGS
#undef INIT_POS_PTR

//
// Test case
//
#tcase castle_tests

#define TEST_WITH_ARGS( fen, side, expected_rawcode, expected_castle_error ) \
    ck_assert( !che_fen_validator(fen) ); \
    p = fen_to_pos(fen); \
    ck_assert( castle(p, side) == expected_rawcode ); \
    ck_assert( castle_error == expected_castle_error ); \
    free(p);

#test C_castle_returns_zero_and_sets_CASTLE_NO_CASTLING_RIGHT
    Pos *p;
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R w Qkq - 10 50", "kingside",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R w Kkq - 10 50", "queenside",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R b KQq - 10 50", "h-side",
        0, CASTLE_NO_CASTLING_RIGHT )
    TEST_WITH_ARGS( "r3k2r/8/8/8/8/8/8/R3K2R b KQk - 10 50", "a-side",
        0, CASTLE_NO_CASTLING_RIGHT )

#test C_castle_returns_zero_and_sets_CASTLE_KING_IN_CHECK
    Pos *p;
    TEST_WITH_ARGS( "4r1kr/8/8/8/8/8/6R1/6K1 b he - 5 50", "kingside",
        0, CASTLE_KING_IN_CHECK )
    TEST_WITH_ARGS( "4r1kr/8/8/8/8/8/6R1/6K1 b he - 5 50", "queenside",
        0, CASTLE_KING_IN_CHECK )

#test C_castle_returns_zero_and_sets_CASTLE_KINGS_PATH_BLOCKED
    Pos *p;
    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/4K1NR w K - 0 100", "kingside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/4KB1R w K - 0 100", "h-side",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( FEN_STD_START_POS, "kingside",
        0, CASTLE_KINGS_PATH_BLOCKED )
    TEST_WITH_ARGS( FEN_STD_START_POS, "queenside",
        0, CASTLE_KINGS_PATH_BLOCKED )

#test C_castle_returns_zero_and_sets_CASTLE_KINGS_PATH_IN_CHECK
    Pos *p;
    TEST_WITH_ARGS( "4rk1r/8/8/8/8/8/6R1/6K1 b he - 5 50", "h-side",
        0, CASTLE_KINGS_PATH_IN_CHECK )
    TEST_WITH_ARGS( "r5k1/8/8/8/8/8/5R2/5K2 b a - 0 123", "a-side", // Invert
        0, CASTLE_KINGS_PATH_IN_CHECK )
    TEST_WITH_ARGS( "r5k1/8/2B5/8/8/8/8/5K2 b a - 0 123", "a-side",
        0, CASTLE_KINGS_PATH_IN_CHECK )
    TEST_WITH_ARGS( "r5k1/2P5/8/8/8/8/8/5K2 b a - 0 123", "queenside",
        0, CASTLE_KINGS_PATH_IN_CHECK )

#test C_castle_returns_920_and_sets_CASTLE_OK
    Pos *p;
    TEST_WITH_ARGS( "8/8/8/8/8/4k3/8/4K2R w K - 0 50", "kingside",
        920, CASTLE_OK )
    TEST_WITH_ARGS( "b3k3/6Q1/8/8/8/3NN3/8/4K2R w H - 10 80", "h-side",
        920, CASTLE_OK )

#test C_castle_returns_1576_and_sets_CASTLE_OK
    Pos *p;
    TEST_WITH_ARGS( "r5k1/P7/8/8/8/8/8/5K2 b a - 0 123", "queenside",
        1576, CASTLE_OK )

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase move_info_tests

#define TEST_WITH_ARGS( fen_arg, code_arg, expected_mibs ) \
    ck_assert( !che_fen_validator(fen_arg) ); \
    p = fen_to_pos(fen_arg); \
    ck_assert( move_info(p, code_arg) == (expected_mibs) ); \
    free(p);

#test C_move_info_tested_with_kingside_castling_moves
    Pos *p;
    ck_assert( (MIB_CASTLE | MIB_KINGSIDE) == 3 ); // 3 = 2^1 + 2^0

    TEST_WITH_ARGS( "4k3/8/8/8/8/8/8/4K2R w K - 0 1",
        920, MIB_CASTLE | MIB_KINGSIDE )
    TEST_WITH_ARGS(
        "qrnb1krn/p1p2ppp/1p6/1b1p4/3P4/4P3/PP2NPPP/QR1BBKRN w BGbg - 0 6",
        1160, MIB_CASTLE | MIB_KINGSIDE )
    TEST_WITH_ARGS(
        "r3k2r/8/8/8/4P3/8/8/R3K2R b KQkq e3 0 99",
        1140, MIB_CASTLE | MIB_KINGSIDE )
    TEST_WITH_ARGS(
        "r1bqk2r/2ppbppp/p1n2n2/1p2p3/4P3/1B3N2/PPPP1PPP/RNBQR1K1 b kq - 1 7",
        1140, MIB_CASTLE | MIB_KINGSIDE )

#test C_move_info_tested_with_queenside_castling_moves
    Pos *p;
    ck_assert( MIB_CASTLE == 1 );

    TEST_WITH_ARGS( "4k3/8/8/8/8/8/8/R3K3 w Q - 12 99",
        897, MIB_CASTLE )
    TEST_WITH_ARGS(
        "1r2krbq/p1pp2bp/4p1p1/3nPp2/3P1P2/1N1N2P1/PPP4P/1R2KRBQ w FBfb f6 0 11",
        899, MIB_CASTLE )
    TEST_WITH_ARGS( "r3k2r/8/8/8/4P3/8/8/R3K2R b KQkq e3 0 149",
        1117, MIB_CASTLE )
    TEST_WITH_ARGS( "3rk1r1/P7/8/8/8/8/8/4K1R1 b Gdg - 10 50",
        1125, MIB_CASTLE )

    // printf( "Code: %u\n", rawcode( "e8a8" ) );

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase rawcodes_tests_with_simple_positions

#test C_rawcodes_tested_with_kings_and_rooks_only
    const char fen[] = "8/8/8/8/8/4k3/8/R3K2R w KQ - 1 100";
    ck_assert( !che_fen_validator(fen) );
    Pos *p = fen_to_pos(fen);
    Rawcode *codes = rawcodes(p);
    ck_assert( !codes[ codes[0] + 1 ] );
    printf( "codes[0] = %u\n", codes[0] );
    for( int i = 1; i <= codes[0]; i++ ) {
        char move[4 + 1];
        rawmove( codes[i], move );
        printf( "RESULT: %s (%u)\n", move, codes[i] );
    }
    free(codes);
    free(p);
