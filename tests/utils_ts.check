#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include "../src/base.h"
#include "../src/utils.h"
#include "../src/chester.h"
#include "../src/move_gen.h"
#include "../src/validation.h"
#include "../src/extra.h"

// Returns the hash pattern squares of the square argument. For example,
// hps_of_sq( "e4" ) returns the following string:
// "e5 f5 f4 f3 e3 d3 d4 d5 f6 g5 g3 f2 d2 c3 c5 d6"
// Another example: hps_of_sq( "a1" ) returns
// "a2 b2 b1 - - - - - b3 c2 - - - - - -"
char *
hps_of_sq( const char *sq_name, bool use_alt_impl ) // Hash pattern squares of square
{
    char *hps = (char *) malloc( 48 ); // 48 = 16 * 3
    int current_pos = 0; // Indicates the current position in the char array

    for( enum sq_dir dir = NORTH; dir <= ELEVEN_OCLOCK; dir++ ) {
        assert( current_pos < 48 );

        const char *sq_in_dir = use_alt_impl ?
            ALT_sq_navigator( sq_name, dir ) : sq_navigator( sq_name, dir );
        if( sq_in_dir ) {
            *( hps + current_pos ) = *sq_in_dir;
            *( hps + current_pos + 1 ) = *( sq_in_dir + 1 );
            *( hps + current_pos + 2 ) = ( dir < ELEVEN_OCLOCK ) ? ' ' : 0;

            current_pos += 3;
        }
        else {
            *( hps + current_pos ) = '-';
            *( hps + current_pos + 1 ) = ( dir < ELEVEN_OCLOCK ) ? ' ' : 0;

            current_pos += 2;
        }
    }

    assert( strlen( hps ) >= 36 && strlen( hps ) <= 47 );
    return hps;
}

#suite utils_ts

//
// Test case
//
#tcase occupant_of_sq_tests

#define TEST_WITH_ARGS( sq_bit_arg, expected_cm ) \
    ck_assert( occupant_of_sq(p, sq_bit_arg) == expected_cm );

#test C_occupant_of_sq_tested_with_the_standard_starting_position
    Pos *p = fen_to_pos(INIT_POS);

    for( int i = 16; i <= 47; i++ ) {
        TEST_WITH_ARGS( SBA[i], EMPTY_SQUARE )
    }
    TEST_WITH_ARGS( SB.e1, WHITE_KING )
    TEST_WITH_ARGS( SB.d1, WHITE_QUEEN )
    TEST_WITH_ARGS( SB.a1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.h1, WHITE_ROOK )
    TEST_WITH_ARGS( SB.c1, WHITE_BISHOP )
    TEST_WITH_ARGS( SB.f1, WHITE_BISHOP )
    TEST_WITH_ARGS( SB.b1, WHITE_KNIGHT )
    TEST_WITH_ARGS( SB.g1, WHITE_KNIGHT )
    for( int i = 8; i <= 15; i++ ) {
        TEST_WITH_ARGS( SBA[i], WHITE_PAWN )
    }
    TEST_WITH_ARGS( SB.e8, BLACK_KING )
    TEST_WITH_ARGS( SB.d8, BLACK_QUEEN )
    TEST_WITH_ARGS( SB.a8, BLACK_ROOK )
    TEST_WITH_ARGS( SB.h8, BLACK_ROOK )
    TEST_WITH_ARGS( SB.c8, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.f8, BLACK_BISHOP )
    TEST_WITH_ARGS( SB.b8, BLACK_KNIGHT )
    TEST_WITH_ARGS( SB.g8, BLACK_KNIGHT )
    for( int i = 48; i <= 55; i++ ) {
        TEST_WITH_ARGS( SBA[i], BLACK_PAWN )
    }

    free(p);

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase file_of_sq_tests

#define SQ_BIT_FILE_TEST_FOR_LOOP( file_char ) \
    const int START_VAL = file_char - 'a'; \
    for( int i = START_VAL; i <= START_VAL + 56; i += 8 ) \
        ck_assert( file_of_sq( SBA[ i ] ) == file_char );

#test C_file_of_sq_test_on_file_a
    SQ_BIT_FILE_TEST_FOR_LOOP( 'a' )

#test C_file_of_sq_test_on_file_b
    SQ_BIT_FILE_TEST_FOR_LOOP( 'b' )

#test C_file_of_sq_test_on_file_c
    SQ_BIT_FILE_TEST_FOR_LOOP( 'c' )

#test C_file_of_sq_test_on_file_d
    SQ_BIT_FILE_TEST_FOR_LOOP( 'd' )

#test C_file_of_sq_test_on_file_e
    SQ_BIT_FILE_TEST_FOR_LOOP( 'e' )

#test C_file_of_sq_test_on_file_f
    SQ_BIT_FILE_TEST_FOR_LOOP( 'f' )

#test C_file_of_sq_test_on_file_g
    SQ_BIT_FILE_TEST_FOR_LOOP( 'g' )

#test C_file_of_sq_test_on_file_h
    SQ_BIT_FILE_TEST_FOR_LOOP( 'h' )

//
// Test case
//
#tcase rank_of_sq_tests

#define SQ_BIT_RANK_TEST_FOR_LOOP( rank_char ) \
    const int START_VAL = ( rank_char - '1' ) * 8; \
    for( int i = START_VAL; i <= START_VAL + 7; i++ ) \
        ck_assert( rank_of_sq( SBA[ i ] ) == rank_char );

#test C_rank_of_sq_test_on_rank_1
    SQ_BIT_RANK_TEST_FOR_LOOP( '1' )

#test C_rank_of_sq_test_on_rank_2
    SQ_BIT_RANK_TEST_FOR_LOOP( '2' )

#test C_rank_of_sq_test_on_rank_3
    SQ_BIT_RANK_TEST_FOR_LOOP( '3' )

#test C_rank_of_sq_test_on_rank_4
    SQ_BIT_RANK_TEST_FOR_LOOP( '4' )

#test C_rank_of_sq_test_on_rank_5
    SQ_BIT_RANK_TEST_FOR_LOOP( '5' )

#test C_rank_of_sq_test_on_rank_6
    SQ_BIT_RANK_TEST_FOR_LOOP( '6' )

#test C_rank_of_sq_test_on_rank_7
    SQ_BIT_RANK_TEST_FOR_LOOP( '7' )

#test C_rank_of_sq_test_on_rank_8
    SQ_BIT_RANK_TEST_FOR_LOOP( '8' )

#tcase str_m_pat_tests

#test C_str_m_pat_returns_true
    ck_assert( str_m_pat( "", "^$" ) );
    ck_assert( str_m_pat( "abcdefghijklmnopqrstuvwxyz", "^[a-z]*$" ) );
    ck_assert( str_m_pat( "John123", "^[a-zA-Z0-9]*$" ) );
    ck_assert( str_m_pat( "John123", "^[a-zA-Z0-9]{7}$" ) );
    ck_assert( str_m_pat( "John123", "^[a-zA-Z0-9]{5,}$" ) );

#test C_str_m_pat_returns_false
    ck_assert( !str_m_pat( " ", "^$" ) );
    ck_assert( !str_m_pat( "John", "^[a-z]*$" ) );
    ck_assert( !str_m_pat( "John123", "^[a-zA-Z0-9]$" ) );
    ck_assert( !str_m_pat( "John123", "^[a-zA-Z0-9]{8}$" ) );
    ck_assert( !str_m_pat( "John123", "^[a-zA-Z0-9]{,5}$" ) );

#tcase uint64_to_bin_str_tests

#define UINT64_TO_BIN_STR_WORKS( uint64, str_constant ) \
bin_str = uint64_to_bin_str( uint64 ); \
ck_assert( !strcmp( str_constant, bin_str ) ); \
free( bin_str );

#test C_uint64_to_bin_str_works
    char *bin_str;

    UINT64_TO_BIN_STR_WORKS( 0u,
        "0000000000000000000000000000000000000000000000000000000000000000" )
    UINT64_TO_BIN_STR_WORKS( 1u,
        "0000000000000000000000000000000000000000000000000000000000000001" )
    UINT64_TO_BIN_STR_WORKS( 0xffffffffffffffffU,
        "1111111111111111111111111111111111111111111111111111111111111111" )
    UINT64_TO_BIN_STR_WORKS( 0xaaaaaaaaaaaaaaaaU,
        "1010101010101010101010101010101010101010101010101010101010101010" )

// Not that there's much to test with this function, really
#tcase print_pos_var_tests

#test C_print_pos_var_inspect_the_output_test
    ck_assert( true );
    // print_pos_var( fen_to_pos( STD_START_POS_FEN ) );

#tcase sq_navigator_tests

#test C_sq_navigator_returns_NULL
    ck_assert( !sq_navigator( "a8", NORTH ) );
    ck_assert( !sq_navigator( "e8", NORTH ) );
    ck_assert( !sq_navigator( "h8", NORTH ) );
    ck_assert( !sq_navigator( "g8", NORTHEAST ) );
    ck_assert( !sq_navigator( "h7", NORTHEAST ) );

#test C_sq_navigator_returns_e4
    char *a[] = { "e3", "d3", "d4", "d5", "e5", "f5", "f4", "f3", "d2", "c3",
        "c5", "d6", "f6", "g5", "g3", "f2", NULL };

    for( enum sq_dir dir = NORTH; dir <= ELEVEN_OCLOCK; dir++ ) {
        const char *ret_sq_name = sq_navigator( a[ dir ], dir );
        ck_assert( ret_sq_name );
        ck_assert( !strcmp( "e4", ret_sq_name ) );
    }

#test C_sq_navigator_comprehensive_test_with_alt_impl
    for( int i = 0; i < 64; i++ ) {
        char *hps = hps_of_sq( SQ_NAME[ i ], false ),
            *hps_from_alt_impl = hps_of_sq( SQ_NAME[ i ], true );
        // printf( "PRI: %s: %s\n", SQ_NAME[ i ], hps );
        // printf( "SEC: %s: %s\n\n", SQ_NAME[ i ], hps_from_alt_impl );
        ck_assert( !strcmp( hps, hps_from_alt_impl ) );
        free( hps );
        free( hps_from_alt_impl );
    }

//
// Test case
//
#tcase bit_count_tests

#test bit_count_returns_0
    ck_assert(!bit_count(0));

#test bit_count_returns_1
    for(int i = 0; i < 64; i++) ck_assert(1 == bit_count(ONE << i));

#test bit_count_returns_8
    for(int file_letter = 'a'; file_letter <= 'h'; file_letter++)
        ck_assert(8 == bit_count(file(file_letter)));
    for(int rank_number = '1'; rank_number <= '8'; rank_number++)
        ck_assert(8 == bit_count(rank(rank_number)));

#test bit_count_returns_64
    ck_assert(64 == bit_count(0xffffffffffffffffU));

//
// Test case
//
#tcase file_and_rank_to_sq_name_tests

#test C_file_and_rank_to_sq_name_works
    ck_assert( !strcmp( "e4", file_and_rank_to_sq_name( 'e', '4' ) ) );
    ck_assert( !strcmp( "a1", file_and_rank_to_sq_name( 'a', '1' ) ) );
    ck_assert( !strcmp( "h1", file_and_rank_to_sq_name( 'h', '1' ) ) );
    ck_assert( !strcmp( "a8", file_and_rank_to_sq_name( 'a', '8' ) ) );
    ck_assert( !strcmp( "h8", file_and_rank_to_sq_name( 'h', '8' ) ) );

//
// Test case
//
#tcase expand_ppf_rank_tests

#test C_expand_ppf_rank_test
    char expanded_ppf_rank[ 8 + 1 ];
    const char *ppf_ranks_and_expected_results[] = {
        "8", "--------",
        "pppppppp", "pppppppp",
        "RNBQKBNR", "RNBQKBNR",
        "7K", "-------K",
        "K7", "K-------",
        "q1q1q3", "q-q-q---",
        // Personally significant PPF
        "6k1", "------k-",
        "r1q1b2n", "r-q-b--n",
        "6QP", "------QP",
        "p3R3", "p---R---",
        "1p3p2", "-p---p--",
        "1P6", "-P------",
        "1PP2P2", "-PP--P--",
        "2K4R", "--K----R",
        NULL };

    for( int i = 0; ppf_ranks_and_expected_results[ i ]; i += 2 ) {
        expand_ppf_rank( ppf_ranks_and_expected_results[ i ], expanded_ppf_rank );
        ck_assert( !strcmp( expanded_ppf_rank,
            ppf_ranks_and_expected_results[ i + 1 ] ) );
    }

//
// Test case
//
#tcase compress_eppf_rank_tests

#test C_compress_eppf_rank_test
    char comp_ppf_rank[ 8 + 1 ];
    const char *eppf_ranks_and_er[] = { // er, expected results
        "--------", "8",
        "pppppppp", "pppppppp",
        "PPPPPPPP", "PPPPPPPP",
        "rnbqkbnr", "rnbqkbnr",
        "RNBQKBNR", "RNBQKBNR",
        "K-------", "K7",
        "-------K", "7K",
        "p-p-----", "p1p5",
        "-p-p----", "1p1p4",
        "--p-p---", "2p1p3",
        "---p-p--", "3p1p2",
        "----p-p-", "4p1p1",
        "-----p-p", "5p1p",
        // Personally significant PPF
        "------k-", "6k1",
        "r-q-b--n", "r1q1b2n",
        "------QP", "6QP",
        "p---R---", "p3R3",
        "-p---p--", "1p3p2",
        "-P------", "1P6",
        "-PP--P--", "1PP2P2",
        "--K----R", "2K4R",
        NULL };

    for( int i = 0; eppf_ranks_and_er[ i ]; i += 2 ) {
        compress_eppf_rank( eppf_ranks_and_er[ i ], comp_ppf_rank );
        ck_assert( !strcmp( comp_ppf_rank, eppf_ranks_and_er[ i + 1 ] ) );
    }

//
// Test case
//
#tcase expand_ppf_tests

#test C_expand_ppf_test
    char eppf[ PPF_MAX_LENGTH + 1 ];
    const char *input_and_exp_output[] = {
        "8/8/8/8/8/8/8/8",
            "--------/--------/--------/--------/--------/--------/--------/--------",
        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR",
            "rnbqkbnr/pppppppp/--------/--------/--------/--------/PPPPPPPP/RNBQKBNR",
        "rn2kb1r/ppp1qppp/5n2/4p3/2B1P3/1Q6/PPP2PPP/RNB1K2R",
            "rn--kb-r/ppp-qppp/-----n--/----p---/--B-P---/-Q------/PPP--PPP/RNB-K--R",
        "pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp",
            "pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp",
        // Personally significant PPF
        "6k1/r1q1b2n/6QP/p3R3/1p3p2/1P6/1PP2P2/2K4R",
            "------k-/r-q-b--n/------QP/p---R---/-p---p--/-P------/-PP--P--/--K----R",
        NULL };

    for( int i = 0; input_and_exp_output[ i ]; i += 2 ) {
        expand_ppf( input_and_exp_output[ i ], eppf );
        ck_assert( !strcmp( eppf, input_and_exp_output[ i + 1 ] ) );
    }

//
// Test case
//
#tcase compress_eppf_tests

#test compress_eppf_test
    const char *input_and_exp_output[] = {
        "----k---/--------/--------/--------/--------/--------/--------/----K---",
            "4k3/8/8/8/8/8/8/4K3",
        "rnbqkbnr/pppppppp/--------/--------/--------/--------/PPPPPPPP/RNBQKBNR",
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR",
        "rn--kb-r/ppp-qppp/-----n--/----p---/--B-P---/-Q------/PPP--PPP/RNB-K--R",
            "rn2kb1r/ppp1qppp/5n2/4p3/2B1P3/1Q6/PPP2PPP/RNB1K2R",
        "pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp",
            "pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp/pppppppp",
        // Personally significant PPF
        "------k-/r-q-b--n/------QP/p---R---/-p---p--/-P------/-PP--P--/--K----R",
            "6k1/r1q1b2n/6QP/p3R3/1p3p2/1P6/1PP2P2/2K4R",
        NULL };

    for( int i = 0; input_and_exp_output[ i ]; i += 2 ) {
        char *ppf = compress_eppf( input_and_exp_output[ i ] );
        ck_assert( !strcmp( ppf, input_and_exp_output[ i + 1 ] ) );
        free( ppf );
    }

//
// Test case
//
#tcase compress_eppf_and_expand_ppf_inverse_fn_tests

#test C_inner_fn_compress_eppf_outer_fn_expand_ppf
    char computed_eppf[ PPF_MAX_LENGTH + 1 ];
    const char *input_eppf[] = {
        "r---r-k-/pp---pbp/-qp---p-/--B-----/--BP--b-/Q-n--N--/P----PPP/---R-K-R",
        // Opera game position. PPF equivalent:
        // "3rkb1r/p2nqppp/5n2/1B2p1B1/4P3/1Q6/PPP2PPP/2KR3R"
        "---rkb-r/p--nqppp/-----n--/-B--p-B-/----P---/-Q------/PPP--PPP/--KR---R",
        // Equivalent PPF: "8/8/8/8/7k/6pq/R1R5/4K3"
        "--------/--------/--------/--------/-------k/------pq/R-R-----/----K---",
        NULL };

    for( int i = 0; input_eppf[ i ]; i++ ) {
        char *ppf = compress_eppf( input_eppf[ i ] );
        expand_ppf( ppf, computed_eppf );
        ck_assert( !strcmp( computed_eppf, input_eppf[ i ] ) );
        free( ppf );
    }

#test C_inner_fn_expand_ppf_outer_fn_compress_eppf
    char computed_eppf[ PPF_MAX_LENGTH + 1 ];
    const char *input_ppf[] = {
        "3rkb1r/p2nqppp/5n2/1B2p1B1/4P3/1Q6/PPP2PPP/2KR3R",
        "8/8/8/8/7k/6pq/R1R5/4K3",
        // Personally significant PPF
        "6k1/r1q1b2n/6QP/p3R3/1p3p2/1P6/1PP2P2/2K4R",
        NULL };

    for( int i = 0; input_ppf[ i ]; i++ ) {
        expand_ppf( input_ppf[ i ], computed_eppf );
        char *output_ppf = compress_eppf( computed_eppf );
        ck_assert( !strcmp( input_ppf[ i ], output_ppf ) );
        free( output_ppf );
    }

//
// Test case
//
#tcase fen_fields_tests

#define FEN_FIELDS_WORKS( fen, exp_ppf, exp_acf, exp_caf, exp_eptsf, \
        exp_hmcf, exp_fmnf ) \
    ck_assert( !che_fen_validator( fen ) ); \
    ck_assert( ( ff = fen_fields( fen ) ) ); \
    exp_vals[ 0 ] = exp_ppf, exp_vals[ 1 ] = exp_acf, \
        exp_vals[ 2 ] = exp_caf, exp_vals[ 3 ] = exp_eptsf, \
        exp_vals[ 4 ] = exp_hmcf, exp_vals[ 5 ] = exp_fmnf; \
    for( int i = 0; i < 6; i++ ) \
        ck_assert( !strcmp( ff[ i ], exp_vals[ i ] ) ); \
    free_fen_fields( ff );

#test C_fen_fields_works
    char **ff, *exp_vals[ 6 ];

    FEN_FIELDS_WORKS( INIT_POS,
        "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR",
        "w", "KQkq", "-", "0", "1" )
    FEN_FIELDS_WORKS( "rn1qkbnr/ppp2ppp/8/4p3/4P3/5Q2/PPP2PPP/RNB1KB1R "
        "w KQkq - 0 6",
        "rn1qkbnr/ppp2ppp/8/4p3/4P3/5Q2/PPP2PPP/RNB1KB1R",
        "w", "KQkq", "-", "0", "6" )
    FEN_FIELDS_WORKS( "rn1qkbnr/ppp2ppp/8/4p3/2B1P3/5Q2/PPP2PPP/RNB1K2R "
        "b KQkq - 1 6",
        "rn1qkbnr/ppp2ppp/8/4p3/2B1P3/5Q2/PPP2PPP/RNB1K2R",
        "b", "KQkq", "-", "1", "6" )
    FEN_FIELDS_WORKS( "rn1qkb1r/ppp2ppp/5n2/4p3/2B1P3/5Q2/PPP2PPP/RNB1K2R "
        "w KQkq - 2 7",
        "rn1qkb1r/ppp2ppp/5n2/4p3/2B1P3/5Q2/PPP2PPP/RNB1K2R",
        "w", "KQkq", "-", "2", "7" )
    FEN_FIELDS_WORKS( "rn1qkb1r/ppp2ppp/5n2/4p3/2B1P3/1Q6/PPP2PPP/RNB1K2R "
        "b KQkq - 3 7",
        "rn1qkb1r/ppp2ppp/5n2/4p3/2B1P3/1Q6/PPP2PPP/RNB1K2R",
        "b", "KQkq", "-", "3", "7" )
    FEN_FIELDS_WORKS( "rn2kb1r/ppp1qppp/5n2/4p3/2B1P3/1Q6/PPP2PPP/RNB1K2R "
        "w KQkq - 4 8",
        "rn2kb1r/ppp1qppp/5n2/4p3/2B1P3/1Q6/PPP2PPP/RNB1K2R",
        "w", "KQkq", "-", "4", "8" )
    FEN_FIELDS_WORKS( "4k3/8/8/8/8/8/8/4K3 w - - 1337 23456",
        "4k3/8/8/8/8/8/8/4K3", "w", "-", "-", "1337", "23456" )
    FEN_FIELDS_WORKS( "8/8/6k1/8/3P4/2PBP1r1/7r/3K4 b - - 10 100",
        "8/8/6k1/8/3P4/2PBP1r1/7r/3K4", "b", "-", "-", "10", "100" )
    FEN_FIELDS_WORKS( "rnbkrbqn/pppppppp/8/8/8/8/PPPPPPPP/RNBKRBQN "
        "w AEae - 0 1",
        "rnbkrbqn/pppppppp/8/8/8/8/PPPPPPPP/RNBKRBQN",
        "w", "AEae", "-", "0", "1" )

#undef FEN_FIELDS_WORKS

//
// Test case
//
#tcase expand_caf_tests

#define STD_FEN_CAF_TEST( caf, exp_ecaf ) \
if( !strcmp( exp_ecaf, "" ) ) ck_assert( false ); \
expand_caf( caf, ecaf ); \
ck_assert( !strcmp( ecaf, exp_ecaf ) );

#test C_expand_caf_tested_with_all_standard_FEN_CAFs
    char ecaf[ 9 + 1 ];

    STD_FEN_CAF_TEST( "-", "----" )
    STD_FEN_CAF_TEST( "K", "-H--" )
    STD_FEN_CAF_TEST( "Q", "A---" )
    STD_FEN_CAF_TEST( "k", "---h" )
    STD_FEN_CAF_TEST( "q", "--a-" )
    STD_FEN_CAF_TEST( "KQ", "AH--" )
    STD_FEN_CAF_TEST( "Kk", "-H-h" )
    STD_FEN_CAF_TEST( "Kq", "-Ha-" )
    STD_FEN_CAF_TEST( "Qk", "A--h" )
    STD_FEN_CAF_TEST( "Qq", "A-a-" )
    STD_FEN_CAF_TEST( "kq", "--ah" )
    STD_FEN_CAF_TEST( "Qkq", "A-ah" )
    STD_FEN_CAF_TEST( "Kkq", "-Hah" )
    STD_FEN_CAF_TEST( "KQq", "AHa-" )
    STD_FEN_CAF_TEST( "KQk", "AH-h" )
    STD_FEN_CAF_TEST( "KQkq", "AHah" )

#undef STD_FEN_CAF_TEST

#test C_expand_caf_tested_with_all_4_char_Shredder_FEN_CAFs
    char ecaf[ 9 + 1 ];
    int tested_cafs_count = 0;
    for( int i = 0; i < SHREDDER_FEN_CAFS_COUNT; i++ ) {
        const char *caf = SHREDDER_FEN_CAFS[ i ];
        if( strlen( caf ) == 4 ) {
            expand_caf( caf, ecaf );
            if( caf[ 0 ] < caf[ 1 ] ) {
                ++tested_cafs_count;
                ck_assert( !strcmp( caf, ecaf ) );
            } else if( caf[ 0 ] > caf[ 1 ] ) {
                ++tested_cafs_count;
                ck_assert( caf[ 0 ] == ecaf[ 1 ] && caf[ 1 ] == ecaf[ 0 ] &&
                    caf[ 2 ] == ecaf[ 3 ] && caf[ 3 ] == ecaf[ 2 ] );
            } else ck_assert( false );
        }
    }
    ck_assert( tested_cafs_count == 2 * POSSIBLE_IRPF_VALUES_COUNT );

#define THREE_CHAR_CAF_TEST( caf, exp_ecaf ) \
if( !strcmp( exp_ecaf, "" ) ) ck_assert( false ); \
expand_caf( caf, ecaf ); \
ck_assert( !strcmp( ecaf, exp_ecaf ) );

#test C_expand_caf_tested_with_some_3_char_Shredder_FEN_CAFs
    char ecaf[ 9 + 1 ];

    THREE_CHAR_CAF_TEST( "Aac", "A-ac" )
    // THREE_CHAR_CAF_TEST( "Aad", "" )
    // THREE_CHAR_CAF_TEST( "Aae", "" )
    THREE_CHAR_CAF_TEST( "Aaf", "A-af" )
    // THREE_CHAR_CAF_TEST( "Aag", "" )
    // THREE_CHAR_CAF_TEST( "Aah", "" )
    // THREE_CHAR_CAF_TEST( "Aca", "" )
    THREE_CHAR_CAF_TEST( "ACa", "ACa-" )
    // THREE_CHAR_CAF_TEST( "ACc", "" )
    // THREE_CHAR_CAF_TEST( "Ada", "" )
    THREE_CHAR_CAF_TEST( "ADa", "ADa-" )
    // THREE_CHAR_CAF_TEST( "ADd", "" )
    // THREE_CHAR_CAF_TEST( "Aea", "" )
    // THREE_CHAR_CAF_TEST( "AEa", "" )
    THREE_CHAR_CAF_TEST( "AEe", "AE-e" )
    // THREE_CHAR_CAF_TEST( "Afa", "" )
    // THREE_CHAR_CAF_TEST( "AFa", "" )
    THREE_CHAR_CAF_TEST( "AFf", "AF-f" )
    // THREE_CHAR_CAF_TEST( "Aga", "" )
    // THREE_CHAR_CAF_TEST( "AGa", "" )
    // THREE_CHAR_CAF_TEST( "AGg", "" )
    THREE_CHAR_CAF_TEST( "Aha", "A-ah" )
    THREE_CHAR_CAF_TEST( "AHa", "AHa-" )
    // THREE_CHAR_CAF_TEST( "AHh", "" )
    THREE_CHAR_CAF_TEST( "Bbd", "B-bd" )
    // THREE_CHAR_CAF_TEST( "Bbe", "" )
    // THREE_CHAR_CAF_TEST( "Bbf", "" )
    // THREE_CHAR_CAF_TEST( "Bbg", "" )
    THREE_CHAR_CAF_TEST( "Bbh", "B-bh" )
    // THREE_CHAR_CAF_TEST( "Bdb", "" )
    // THREE_CHAR_CAF_TEST( "BDb", "" )
    THREE_CHAR_CAF_TEST( "BDd", "BD-d" )
    // THREE_CHAR_CAF_TEST( "Beb", "" )
    // THREE_CHAR_CAF_TEST( "BEb", "" )
    THREE_CHAR_CAF_TEST( "BEe", "BE-e" )
    // THREE_CHAR_CAF_TEST( "Bfb", "" )
    // THREE_CHAR_CAF_TEST( "BFb", "" )
    THREE_CHAR_CAF_TEST( "BFf", "BF-f" )
    // THREE_CHAR_CAF_TEST( "Bgb", "" )
    // THREE_CHAR_CAF_TEST( "BGb", "" )
    // THREE_CHAR_CAF_TEST( "BGg", "" )
    THREE_CHAR_CAF_TEST( "Bhb", "B-bh" )
    // THREE_CHAR_CAF_TEST( "BHb", "" )
    // THREE_CHAR_CAF_TEST( "BHh", "" )
    // THREE_CHAR_CAF_TEST( "CAa", "" )
    THREE_CHAR_CAF_TEST( "Cac", "-Cac" )
    // THREE_CHAR_CAF_TEST( "CAc", "" )
    // THREE_CHAR_CAF_TEST( "Cca", "" )
    THREE_CHAR_CAF_TEST( "Cce", "C-ce" )
    // THREE_CHAR_CAF_TEST( "Ccf", "" )
    // THREE_CHAR_CAF_TEST( "Ccg", "" )
    THREE_CHAR_CAF_TEST( "Cch", "C-ch" )
    // THREE_CHAR_CAF_TEST( "Cec", "" )
    // THREE_CHAR_CAF_TEST( "CEc", "" )
    THREE_CHAR_CAF_TEST( "CEe", "CE-e" )
    // THREE_CHAR_CAF_TEST( "Cfc", "" )
    // THREE_CHAR_CAF_TEST( "CFc", "" )
    THREE_CHAR_CAF_TEST( "CFf", "CF-f" )
    // THREE_CHAR_CAF_TEST( "Cgc", "" )
    // THREE_CHAR_CAF_TEST( "CGc", "" )
    // THREE_CHAR_CAF_TEST( "CGg", "" )
    THREE_CHAR_CAF_TEST( "Chc", "C-ch" )
    // THREE_CHAR_CAF_TEST( "CHc", "" )
    // THREE_CHAR_CAF_TEST( "CHh", "" )
    THREE_CHAR_CAF_TEST( "DAa", "ADa-" )
    // THREE_CHAR_CAF_TEST( "Dad", "" )
    // THREE_CHAR_CAF_TEST( "DAd", "" )
    THREE_CHAR_CAF_TEST( "DBb", "BDb-" )
    // THREE_CHAR_CAF_TEST( "Dbd", "" )
    // THREE_CHAR_CAF_TEST( "DBd", "" )
    THREE_CHAR_CAF_TEST( "Dda", "-Dad" )
    // THREE_CHAR_CAF_TEST( "Ddb", "" )
    // THREE_CHAR_CAF_TEST( "Ddf", "" )
    THREE_CHAR_CAF_TEST( "Ddg", "D-dg" )
    // THREE_CHAR_CAF_TEST( "Ddh", "" )
    // THREE_CHAR_CAF_TEST( "Dfd", "" )
    // THREE_CHAR_CAF_TEST( "DFd", "" )
    THREE_CHAR_CAF_TEST( "DFf", "DF-f" )
    // THREE_CHAR_CAF_TEST( "Dgd", "" )
    // THREE_CHAR_CAF_TEST( "DGd", "" )
    // THREE_CHAR_CAF_TEST( "DGg", "" )
    // THREE_CHAR_CAF_TEST( "Dhd", "" )
    // THREE_CHAR_CAF_TEST( "DHd", "" )
    THREE_CHAR_CAF_TEST( "DHh", "DH-h" )
    // THREE_CHAR_CAF_TEST( "EAa", "" )
    // THREE_CHAR_CAF_TEST( "Eae", "" )
    // THREE_CHAR_CAF_TEST( "EAe", "" )
    // THREE_CHAR_CAF_TEST( "EBb", "" )
    // THREE_CHAR_CAF_TEST( "Ebe", "" )
    // THREE_CHAR_CAF_TEST( "EBe", "" )
    THREE_CHAR_CAF_TEST( "ECc", "CEc-" )
    // THREE_CHAR_CAF_TEST( "Ece", "" )
    // THREE_CHAR_CAF_TEST( "ECe", "" )
    // THREE_CHAR_CAF_TEST( "Eea", "" )
    // THREE_CHAR_CAF_TEST( "Eeb", "" )
    // THREE_CHAR_CAF_TEST( "Eec", "" )
    // THREE_CHAR_CAF_TEST( "Eeg", "" )
    // THREE_CHAR_CAF_TEST( "Eeh", "" )
    // THREE_CHAR_CAF_TEST( "Ege", "" )
    // THREE_CHAR_CAF_TEST( "EGe", "" )
    // THREE_CHAR_CAF_TEST( "EGg", "" )
    THREE_CHAR_CAF_TEST( "Ehe", "E-eh" )
    // THREE_CHAR_CAF_TEST( "EHe", "" )
    // THREE_CHAR_CAF_TEST( "EHh", "" )
    // THREE_CHAR_CAF_TEST( "FAa", "" )
    // THREE_CHAR_CAF_TEST( "Faf", "" )
    // THREE_CHAR_CAF_TEST( "FAf", "" )
    THREE_CHAR_CAF_TEST( "FBb", "BFb-" )
    // THREE_CHAR_CAF_TEST( "Fbf", "" )
    // THREE_CHAR_CAF_TEST( "FBf", "" )
    // THREE_CHAR_CAF_TEST( "FCc", "" )
    // THREE_CHAR_CAF_TEST( "Fcf", "" )
    // THREE_CHAR_CAF_TEST( "FCf", "" )
    THREE_CHAR_CAF_TEST( "FDd", "DFd-" )
    // THREE_CHAR_CAF_TEST( "Fdf", "" )
    // THREE_CHAR_CAF_TEST( "FDf", "" )
    // THREE_CHAR_CAF_TEST( "Ffa", "" )
    // THREE_CHAR_CAF_TEST( "Ffb", "" )
    // THREE_CHAR_CAF_TEST( "Ffc", "" )
    // THREE_CHAR_CAF_TEST( "Ffd", "" )
    // THREE_CHAR_CAF_TEST( "Ffh", "" )
    // THREE_CHAR_CAF_TEST( "Fhf", "" )
    THREE_CHAR_CAF_TEST( "FHf", "FHf-" )
    // THREE_CHAR_CAF_TEST( "FHh", "" )
    // THREE_CHAR_CAF_TEST( "GAa", "" )
    // THREE_CHAR_CAF_TEST( "Gag", "" )
    // THREE_CHAR_CAF_TEST( "GAg", "" )
    // THREE_CHAR_CAF_TEST( "GBb", "" )
    // THREE_CHAR_CAF_TEST( "Gbg", "" )
    // THREE_CHAR_CAF_TEST( "GBg", "" )
    // THREE_CHAR_CAF_TEST( "GCc", "" )
    // THREE_CHAR_CAF_TEST( "Gcg", "" )
    // THREE_CHAR_CAF_TEST( "GCg", "" )
    THREE_CHAR_CAF_TEST( "GDd", "DGd-" )
    // THREE_CHAR_CAF_TEST( "Gdg", "" )
    // THREE_CHAR_CAF_TEST( "GDg", "" )
    // THREE_CHAR_CAF_TEST( "GEe", "" )
    // THREE_CHAR_CAF_TEST( "Geg", "" )
    // THREE_CHAR_CAF_TEST( "GEg", "" )
    // THREE_CHAR_CAF_TEST( "Gga", "" )
    // THREE_CHAR_CAF_TEST( "Ggb", "" )
    // THREE_CHAR_CAF_TEST( "Ggc", "" )
    // THREE_CHAR_CAF_TEST( "Ggd", "" )
    // THREE_CHAR_CAF_TEST( "Gge", "" )
    THREE_CHAR_CAF_TEST( "HAa", "AHa-" )
    // THREE_CHAR_CAF_TEST( "Hah", "" )
    // THREE_CHAR_CAF_TEST( "HAh", "" )
    // THREE_CHAR_CAF_TEST( "HBb", "" )
    // THREE_CHAR_CAF_TEST( "Hbh", "" )
    // THREE_CHAR_CAF_TEST( "HBh", "" )
    // THREE_CHAR_CAF_TEST( "HCc", "" )
    THREE_CHAR_CAF_TEST( "Hch", "-Hch" )
    // THREE_CHAR_CAF_TEST( "HCh", "" )
    // THREE_CHAR_CAF_TEST( "HDd", "" )
    // THREE_CHAR_CAF_TEST( "Hdh", "" )
    // THREE_CHAR_CAF_TEST( "HDh", "" )
    // THREE_CHAR_CAF_TEST( "HEe", "" )
    // THREE_CHAR_CAF_TEST( "Heh", "" )
    THREE_CHAR_CAF_TEST( "HEh", "EH-h" )
    // THREE_CHAR_CAF_TEST( "HFf", "" )
    // THREE_CHAR_CAF_TEST( "Hfh", "" )
    // THREE_CHAR_CAF_TEST( "HFh", "" )
    THREE_CHAR_CAF_TEST( "Hha", "-Hah" )
    // THREE_CHAR_CAF_TEST( "Hhb", "" )
    // THREE_CHAR_CAF_TEST( "Hhc", "" )
    THREE_CHAR_CAF_TEST( "Hhd", "-Hdh" )
    // THREE_CHAR_CAF_TEST( "Hhe", "" )
    THREE_CHAR_CAF_TEST( "Hhf", "-Hfh" )

#undef THREE_CHAR_CAF_TEST

#define TWO_CHAR_CAF_TEST( caf, exp_ecaf ) \
if( !strcmp( exp_ecaf, "" ) ) ck_assert( false ); \
expand_caf( caf, ecaf ); \
ck_assert( !strcmp( ecaf, exp_ecaf ) );

#test C_expand_caf_tested_with_some_2_char_Shredder_FEN_CAFs
    char ecaf[ 9 + 1 ];

    TWO_CHAR_CAF_TEST( "Aa", "A-a-" )
    // TWO_CHAR_CAF_TEST( "ac", "" )
    // TWO_CHAR_CAF_TEST( "Ac", "" )
    TWO_CHAR_CAF_TEST( "AC", "AC--" )
    TWO_CHAR_CAF_TEST( "ad", "--ad" )
    // TWO_CHAR_CAF_TEST( "Ad", "" )
    // TWO_CHAR_CAF_TEST( "AD", "" )
    // TWO_CHAR_CAF_TEST( "ae", "" )
    TWO_CHAR_CAF_TEST( "Ae", "A--e" )
    // TWO_CHAR_CAF_TEST( "AE", "" )
    // TWO_CHAR_CAF_TEST( "af", "" )
    // TWO_CHAR_CAF_TEST( "Af", "" )
    // TWO_CHAR_CAF_TEST( "AF", "" )
    TWO_CHAR_CAF_TEST( "ag", "--ag" )
    // TWO_CHAR_CAF_TEST( "Ag", "" )
    // TWO_CHAR_CAF_TEST( "AG", "" )
    TWO_CHAR_CAF_TEST( "ah", "--ah" )
    // TWO_CHAR_CAF_TEST( "Ah", "" )
    // TWO_CHAR_CAF_TEST( "AH", "" )
    TWO_CHAR_CAF_TEST( "Bb", "B-b-" )
    TWO_CHAR_CAF_TEST( "bd", "--bd" )
    TWO_CHAR_CAF_TEST( "Bd", "B--d" )
    // TWO_CHAR_CAF_TEST( "BD", "" )
    // TWO_CHAR_CAF_TEST( "be", "" )
    TWO_CHAR_CAF_TEST( "Be", "B--e" )
    // TWO_CHAR_CAF_TEST( "BE", "" )
    // TWO_CHAR_CAF_TEST( "bf", "" )
    // TWO_CHAR_CAF_TEST( "Bf", "" )
    // TWO_CHAR_CAF_TEST( "BF", "" )
    // TWO_CHAR_CAF_TEST( "bg", "" )
    TWO_CHAR_CAF_TEST( "Bg", "B--g" )
    // TWO_CHAR_CAF_TEST( "BG", "" )
    // TWO_CHAR_CAF_TEST( "bh", "" )
    // TWO_CHAR_CAF_TEST( "Bh", "" )
    TWO_CHAR_CAF_TEST( "BH", "BH--" )
    // TWO_CHAR_CAF_TEST( "ca", "" )
    // TWO_CHAR_CAF_TEST( "Ca", "" )
    // TWO_CHAR_CAF_TEST( "CA", "" )
    TWO_CHAR_CAF_TEST( "Cc", "C-c- -C-c" )
    // TWO_CHAR_CAF_TEST( "ce", "" )
    // TWO_CHAR_CAF_TEST( "Ce", "" )
    // TWO_CHAR_CAF_TEST( "CE", "" )
    TWO_CHAR_CAF_TEST( "cf", "--cf" )
    // TWO_CHAR_CAF_TEST( "Cf", "" )
    // TWO_CHAR_CAF_TEST( "CF", "" )
    // TWO_CHAR_CAF_TEST( "cg", "" )
    // TWO_CHAR_CAF_TEST( "Cg", "" )
    TWO_CHAR_CAF_TEST( "CG", "CG--" )
    // TWO_CHAR_CAF_TEST( "ch", "" )
    // TWO_CHAR_CAF_TEST( "Ch", "" )
    // TWO_CHAR_CAF_TEST( "CH", "" )
    // TWO_CHAR_CAF_TEST( "da", "" )
    TWO_CHAR_CAF_TEST( "Da", "-Da-" )
    // TWO_CHAR_CAF_TEST( "DA", "" )
    // TWO_CHAR_CAF_TEST( "db", "" )
    // TWO_CHAR_CAF_TEST( "Db", "" )
    // TWO_CHAR_CAF_TEST( "DB", "" )
    TWO_CHAR_CAF_TEST( "Dd", "D-d- -D-d" )
    // TWO_CHAR_CAF_TEST( "df", "" )
    // TWO_CHAR_CAF_TEST( "Df", "" )
    TWO_CHAR_CAF_TEST( "DF", "DF--" )
    // TWO_CHAR_CAF_TEST( "dg", "" )
    // TWO_CHAR_CAF_TEST( "Dg", "" )
    // TWO_CHAR_CAF_TEST( "DG", "" )
    TWO_CHAR_CAF_TEST( "dh", "--dh" )
    // TWO_CHAR_CAF_TEST( "Dh", "" )
    // TWO_CHAR_CAF_TEST( "DH", "" )
    // TWO_CHAR_CAF_TEST( "ea", "" )
    TWO_CHAR_CAF_TEST( "Ea", "-Ea-" )
    // TWO_CHAR_CAF_TEST( "EA", "" )
    // TWO_CHAR_CAF_TEST( "eb", "" )
    // TWO_CHAR_CAF_TEST( "Eb", "" )
    TWO_CHAR_CAF_TEST( "EB", "BE--" )
    TWO_CHAR_CAF_TEST( "ec", "--ce" )
    TWO_CHAR_CAF_TEST( "Ec", "-Ec-" )
    // TWO_CHAR_CAF_TEST( "EC", "" )
    TWO_CHAR_CAF_TEST( "Ee", "E-e- -E-e" )
    // TWO_CHAR_CAF_TEST( "eg", "" )
    // TWO_CHAR_CAF_TEST( "Eg", "" )
    // TWO_CHAR_CAF_TEST( "EG", "" )
    TWO_CHAR_CAF_TEST( "eh", "--eh" )
    TWO_CHAR_CAF_TEST( "Eh", "E--h" )
    // TWO_CHAR_CAF_TEST( "EH", "" )
    TWO_CHAR_CAF_TEST( "fa", "--af" )
    // TWO_CHAR_CAF_TEST( "Fa", "" )
    // TWO_CHAR_CAF_TEST( "FA", "" )
    // TWO_CHAR_CAF_TEST( "fb", "" )
    TWO_CHAR_CAF_TEST( "Fb", "-Fb-" )
    // TWO_CHAR_CAF_TEST( "FB", "" )
    // TWO_CHAR_CAF_TEST( "fc", "" )
    TWO_CHAR_CAF_TEST( "Fc", "-Fc-" )
    // TWO_CHAR_CAF_TEST( "FC", "" )
    // TWO_CHAR_CAF_TEST( "fd", "" )
    TWO_CHAR_CAF_TEST( "Fd", "-Fd-" )
    // TWO_CHAR_CAF_TEST( "FD", "" )
    TWO_CHAR_CAF_TEST( "Ff", "F-f- -F-f" )
    // TWO_CHAR_CAF_TEST( "fh", "" )
    // TWO_CHAR_CAF_TEST( "Fh", "" )
    // TWO_CHAR_CAF_TEST( "FH", "" )
    // TWO_CHAR_CAF_TEST( "ga", "" )
    TWO_CHAR_CAF_TEST( "Ga", "-Ga-" )
    // TWO_CHAR_CAF_TEST( "GA", "" )
    // TWO_CHAR_CAF_TEST( "gb", "" )
    // TWO_CHAR_CAF_TEST( "Gb", "" )
    TWO_CHAR_CAF_TEST( "GB", "BG--" )
    // TWO_CHAR_CAF_TEST( "gc", "" )
    // TWO_CHAR_CAF_TEST( "Gc", "" )
    TWO_CHAR_CAF_TEST( "GC", "CG--" )
    // TWO_CHAR_CAF_TEST( "gd", "" )
    // TWO_CHAR_CAF_TEST( "Gd", "" )
    TWO_CHAR_CAF_TEST( "GD", "DG--" )
    // TWO_CHAR_CAF_TEST( "ge", "" )
    TWO_CHAR_CAF_TEST( "Ge", "-Ge-" )
    // TWO_CHAR_CAF_TEST( "GE", "" )
    TWO_CHAR_CAF_TEST( "Gg", "-G-g" )
    // TWO_CHAR_CAF_TEST( "ha", "" )
    // TWO_CHAR_CAF_TEST( "Ha", "" )
    // TWO_CHAR_CAF_TEST( "HA", "" )
    // TWO_CHAR_CAF_TEST( "hb", "" )
    TWO_CHAR_CAF_TEST( "Hb", "-Hb-" )
    // TWO_CHAR_CAF_TEST( "HB", "" )
    // TWO_CHAR_CAF_TEST( "hc", "" )
    // TWO_CHAR_CAF_TEST( "Hc", "" )
    // TWO_CHAR_CAF_TEST( "HC", "" )
    // TWO_CHAR_CAF_TEST( "hd", "" )
    TWO_CHAR_CAF_TEST( "Hd", "-Hd-" )
    // TWO_CHAR_CAF_TEST( "HD", "" )
    // TWO_CHAR_CAF_TEST( "he", "" )
    TWO_CHAR_CAF_TEST( "He", "-He-" )
    // TWO_CHAR_CAF_TEST( "HE", "" )
    TWO_CHAR_CAF_TEST( "hf", "--fh" )
    // TWO_CHAR_CAF_TEST( "Hf", "" )
    TWO_CHAR_CAF_TEST( "HF", "FH--" )
    TWO_CHAR_CAF_TEST( "Hh", "-H-h" )

#undef TWO_CHAR_CAF_TEST

#define ONE_CHAR_CAF_TEST( caf, exp_ecaf ) \
if( !strcmp( exp_ecaf, "" ) ) ck_assert( false ); \
expand_caf( caf, ecaf ); \
ck_assert( !strcmp( ecaf, exp_ecaf ) );

#test C_expand_caf_tested_with_all_1_char_Shredder_FEN_CAFs
    char ecaf[ 9 + 1 ];

    ONE_CHAR_CAF_TEST( "-", "----" )
    ONE_CHAR_CAF_TEST( "a", "--a-" )
    ONE_CHAR_CAF_TEST( "A", "A---" )
    ONE_CHAR_CAF_TEST( "b", "--b-" )
    ONE_CHAR_CAF_TEST( "B", "B---" )
    ONE_CHAR_CAF_TEST( "c", "--c- ---c" )
    ONE_CHAR_CAF_TEST( "C", "C--- -C--" )
    ONE_CHAR_CAF_TEST( "d", "--d- ---d" )
    ONE_CHAR_CAF_TEST( "D", "D--- -D--" )
    ONE_CHAR_CAF_TEST( "e", "--e- ---e" )
    ONE_CHAR_CAF_TEST( "E", "E--- -E--" )
    ONE_CHAR_CAF_TEST( "f", "--f- ---f" )
    ONE_CHAR_CAF_TEST( "F", "F--- -F--" )
    ONE_CHAR_CAF_TEST( "g", "---g" )
    ONE_CHAR_CAF_TEST( "G", "-G--" )
    ONE_CHAR_CAF_TEST( "h", "---h" )
    ONE_CHAR_CAF_TEST( "H", "-H--" )

#undef ONE_CHAR_CAF_TEST

//
// Test case
//
#tcase resolve_ambiguous_ecaf_tests

#define RESOLVE_AMBIGUOUS_ECAF_TEST( fen, exp_ecaf ) \
che_fen_validator( fen ); \
ff = fen_fields( fen ); \
strcpy( caf, ff[ 2 ] ); \
free_fen_fields( ff ); \
EXPAND_CAF( caf, ecaf, fen ) \
ck_assert( !strcmp( ecaf, exp_ecaf ) );

#test C_resolve_ambiguous_ecaf_works_with_1c_ambiguous_ECAFs
    char caf[ 4 + 1 ], ecaf[ 9 + 1 ];
    char **ff;

    RESOLVE_AMBIGUOUS_ECAF_TEST( "1k6/8/8/8/8/8/8/1KR5 w C - 0 60", "-C--" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "1k6/8/8/8/8/8/8/2RK4 b C - 0 60", "C---" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "k7/8/8/8/8/8/8/4RK2 w E - 10 50", "E---" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "k7/8/8/8/8/8/8/3KR3 w E - 10 50", "-E--" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "k7/8/8/8/8/8/8/4KR2 b F - 0 60", "-F--" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "5rk1/8/8/8/8/8/8/6K1 b f - 0 60", "--f-" )

#test C_resolve_ambiguous_ecaf_works_with_2c_ambiguous_ECAFs
    char caf[ 4 + 1 ], ecaf[ 9 + 1 ];
    char **ff;

    RESOLVE_AMBIGUOUS_ECAF_TEST( "3rk3/8/8/8/8/8/8/3RK3 b Dd - 0 60", "D-d-" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "2kr4/8/8/8/8/8/8/2KR4 b Dd - 0 60", "-D-d" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "4rk2/8/8/8/8/8/8/4RK2 b Ee - 10 50", "E-e-" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "3r1k2/8/8/8/8/8/8/3R1K2 b Ee - 10 50", "E-e-" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "1r3k2/8/8/8/8/8/8/1R3K2 w Ee - 10 50", "E-e-" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "r4k2/8/8/8/8/8/8/R4K2 b Ee - 10 50", "E-e-" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "5kr1/8/8/8/8/8/8/5KR1 w Gg - 10 50", "-G-g" )

#test C_resolve_ambiguous_ecaf_works_with_unambiguous_ECAFs
    char caf[ 4 + 1 ], ecaf[ 9 + 1 ];
    char **ff;

    RESOLVE_AMBIGUOUS_ECAF_TEST( INIT_POS, "AHah" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "4k3/8/8/8/8/8/8/1RK5 w B - 0 40", "B---" )
    RESOLVE_AMBIGUOUS_ECAF_TEST( "5kr1/8/8/8/8/8/8/4K3 b g - 0 40", "---g" )

#undef RESOLVE_AMBIGUOUS_ECAF_TEST

//
// Test case
//
#tcase swap_tests

#define ASSIGN_SWAP_AND_ASSERT( left_arg, right_arg, type_arg ) \
    left = left_arg, right = right_arg; \
    swap( left, right, type_arg ); \
    ck_assert( left == right_arg && right == left_arg );

#test C_swap_works_with_type_bool
    bool left, right;

    ASSIGN_SWAP_AND_ASSERT( false, false, bool )
    ASSIGN_SWAP_AND_ASSERT( false, true, bool )
    ASSIGN_SWAP_AND_ASSERT( true, false, bool )
    ASSIGN_SWAP_AND_ASSERT( true, true, bool )

#undef ASSIGN_SWAP_AND_ASSERT

#test C_swap_works_with_type_int
    int left = 1234, right = -1975;
    swap( left, right, int );
    ck_assert( left == -1975 && right == 1234 );

//
// Test case
//
#tcase ppa_to_eppf_tests

#define PPA_TO_EPPF_TEST( empty, \
        wking, wqueen, wrook, wbishop, wknight, wpawn, \
        bking, bqueen, brook, bbishop, bknight, bpawn, \
        expected_eppf ) \
    Bitboard ppa[13]; Bitboard *p = ppa; char eppf[PPF_MAX_LENGTH + 1]; \
    *p++ = empty; *p++ = wking; *p++ = wqueen; *p++ = wrook; *p++ = wbishop; \
    *p++ = wknight; *p++ = wpawn; *p++ = bking; *p++ = bqueen; *p++ = brook; \
    *p++ = bbishop; *p++ = bknight; *p++ = bpawn; \
    ppa_to_eppf( ppa, eppf ); \
    ck_assert( !strcmp( eppf, expected_eppf ) );

#test C_ppa_to_eppf_tested_with_std_start_pos_ppa
    PPA_TO_EPPF_TEST( 0xffffffff0000U,
        0x10U, 0x8U, 0x81U, 0x24U, 0x42U, 0xff00U,
        0x1000000000000000U, 0x800000000000000U, 0x8100000000000000U,
        0x2400000000000000U, 0x4200000000000000U, 0xff000000000000U,
        "rnbqkbnr/pppppppp/--------/--------/--------/--------/PPPPPPPP/RNBQKBNR" )

#test C_ppa_to_eppf_tested_with_personally_significant_ppa
    PPA_TO_EPPF_TEST( 0xbf6a3feeddfdd97bU,
        0x4U, 0x400000000000U, 0x1000000080U, 0, 0, 0x800000022600U,
        0x4000000000000000U, 0x4000000000000U, 0x1000000000000U,
        0x10000000000000U, 0x80000000000000U, 0x122000000U,
        "------k-/r-q-b--n/------QP/p---R---/-p---p--/-P------/-PP--P--/--K----R" )

#test C_ppa_to_eppf_tested_with_empty_board_ppa
    PPA_TO_EPPF_TEST( 0xffffffffffffffff,
        0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,
        "--------/--------/--------/--------/--------/--------/--------/--------" )

#test C_ppa_to_eppf_tested_with_insignificant_ppa_1
    PPA_TO_EPPF_TEST( 0xaa12bfe9ffb912a4,
        0x10, 0x8, 0x42, 1, 0x440000, 0x2ed00,
        0x1000000000000000, 0x8000000000000, 0x4000000200000000,
        0x100000400000000, 0x400400000000000, 0xe5001000000000,
        "b-n-k-r-/p-pq-ppp/------n-/-rb-p---/--------/-PN---N-/P-PP-PPP/BR-QK-R-" )

#undef PPA_TO_EPPF_TEST

//
// Test case
//
#tcase eppf_to_ppa_tests

#define EPPF_TO_PPA_TEST( input_eppf, empty, \
        wking, wqueen, wrook, wbishop, wknight, wpawn, \
        bking, bqueen, brook, bbishop, bknight, bpawn ) \
    Bitboard ppa[13]; \
    eppf_to_ppa( input_eppf, ppa ); \
    ck_assert( ppa[EMPTY_SQUARE] == empty && ppa[WHITE_KING] == wking && \
        ppa[WHITE_QUEEN] == wqueen && ppa[WHITE_ROOK] == wrook && \
        ppa[WHITE_BISHOP] == wbishop && ppa[WHITE_KNIGHT] == wknight && \
        ppa[WHITE_PAWN] == wpawn && ppa[BLACK_KING] == bking && \
        ppa[BLACK_QUEEN] == bqueen && ppa[BLACK_ROOK] == brook && \
        ppa[BLACK_BISHOP] == bbishop && ppa[BLACK_KNIGHT] == bknight && \
        ppa[BLACK_PAWN] == bpawn );

#test C_eppf_to_ppa_tested_with_std_start_pos_ppa
    EPPF_TO_PPA_TEST(
        "rnbqkbnr/pppppppp/--------/--------/--------/--------/PPPPPPPP/RNBQKBNR",
        0xffffffff0000U,
        0x10U, 0x8U, 0x81U, 0x24U, 0x42U, 0xff00U,
        0x1000000000000000U, 0x800000000000000U, 0x8100000000000000U,
        0x2400000000000000U, 0x4200000000000000U, 0xff000000000000U )

#test C_eppf_to_ppa_tested_with_personally_significant_ppa
    EPPF_TO_PPA_TEST(
        "------k-/r-q-b--n/------QP/p---R---/-p---p--/-P------/-PP--P--/--K----R",
        0xbf6a3feeddfdd97bU,
        0x4U, 0x400000000000U, 0x1000000080U, 0, 0, 0x800000022600U,
        0x4000000000000000U, 0x4000000000000U, 0x1000000000000U,
        0x10000000000000U, 0x80000000000000U, 0x122000000U )

#test C_eppf_to_ppa_tested_with_empty_board_ppa
    EPPF_TO_PPA_TEST(
        "--------/--------/--------/--------/--------/--------/--------/--------",
        0xffffffffffffffff,
        0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0 )

#test C_eppf_to_ppa_tested_with_insignificant_ppa_1
    EPPF_TO_PPA_TEST(
        "b-n-k-r-/p-pq-ppp/------n-/-rb-p---/--------/-PN---N-/P-PP-PPP/BR-QK-R-",
        0xaa12bfe9ffb912a4,
        0x10, 0x8, 0x42, 1, 0x440000, 0x2ed00,
        0x1000000000000000, 0x8000000000000, 0x4000000200000000,
        0x100000400000000, 0x400400000000000, 0xe5001000000000 )

#undef EPPF_TO_PPA_TEST

//
// Test case
//
#tcase ppa_to_eppf_and_eppf_to_ppa_inverse_fn_tests

#define GAME_OF_THE_CENTURY_EPPF \
    "r---r-k-/pp---pbp/-qp---p-/--B-----/--BP--b-/Q-n--N--/P----PPP/---R-K-R"

#define GAME_OF_THE_CENTURY_PPA \
    { 0xae1cb9fbb3da1e57U, \
    0x20U, 0x10000U, 0x88U, 0x404000000U, 0x200000U, 0x800e100U, \
    0x4000000000000000U, 0x20000000000U, 0x1100000000000000U, \
    0x40000040000000U, 0x40000U, 0xa3440000000000U }

#test C_inner_fn_ppa_to_eppf_outer_fn_eppf_to_ppa
    const Bitboard century_ppa[] = GAME_OF_THE_CENTURY_PPA;
    char writable_eppf[PPF_MAX_LENGTH + 1];
    Bitboard writable_ppa[13];

    ppa_to_eppf( century_ppa, writable_eppf );
    eppf_to_ppa( writable_eppf, writable_ppa );

    for( int i = 0; i < 13; i++ )
        ck_assert( century_ppa[i] == writable_ppa[i] );

#test C_inner_fn_eppf_to_ppa_outer_fn_ppa_to_eppf
    const char century_eppf[] = GAME_OF_THE_CENTURY_EPPF;
    char writable_eppf[PPF_MAX_LENGTH + 1];
    Bitboard writable_ppa[13];

    eppf_to_ppa( century_eppf, writable_ppa );
    ppa_to_eppf( writable_ppa, writable_eppf );

    ck_assert( !strcmp( GAME_OF_THE_CENTURY_EPPF, writable_eppf ) );

#undef GAME_OF_THE_CENTURY_EPPF
#undef GAME_OF_THE_CENTURY_PPA

//
// Test case
//
#tcase occupant_of_sq_fen_v_tests

#test C_occupant_of_sq_fen_v_tested_with_single_calls
    ck_assert( occupant_of_sq_fen_v( INIT_POS, "e1" ) == 'K' );

#define FULL_TEST( expected_arg, fen_arg ) \
    char expected[] = expected_arg, fen[] = fen_arg; \
    ck_assert( strlen(expected) == 64 ); \
    for( int i = 0; i < 64; i++ ) \
        ck_assert( occupant_of_sq_fen_v( fen, SQ_NAME[i] ) == expected[i] );

#test C_occupant_of_sq_fen_v_tested_with_std_start_pos
    FULL_TEST(
        "RNBQKBNRPPPPPPPP--------------------------------pppppppprnbqkbnr",
        INIT_POS )

#test C_occupant_of_sq_fen_v_tested_with_personally_significant_pos
    FULL_TEST(
        "--K----R"
        "-PP--P--"
        "-P------"
        "-p---p--"
        "p---R---"
        "------QP"
        "r-q-b--n"
        "------k-",
        FEN_PERSONALLY_SIGNIFICANT )

#undef FULL_TEST

//
// Test case
//
#tcase in_between_tests

#define TEST_WITH_ARGS( expected_bb, sq_1, sq_2 ) \
    ck_assert( (expected_bb) == in_between( sq_1, sq_2 ) ); \
    ck_assert( (expected_bb) == in_between( sq_2, sq_1 ) );

#test C_in_between_tested_with_squares_not_on_the_same_file_rank_or_diagonal
    TEST_WITH_ARGS( UINT64_MAX, SB.g1, SB.f3 )
    TEST_WITH_ARGS( UINT64_MAX, SB.e1, SB.d8 )
    TEST_WITH_ARGS( UINT64_MAX, SB.b2, SB.d5 )
    TEST_WITH_ARGS( UINT64_MAX, SB.e4, SB.f6 )

#test C_in_between_tested_with_identical_squares
    for( int i = 0; i < 64; i++ ) {
        TEST_WITH_ARGS( 0, SBA[i], SBA[i] )
    }

#test C_in_between_tested_with_adjacent_squares
    TEST_WITH_ARGS( 0, SB.a1, SB.b1 )
    TEST_WITH_ARGS( 0, SB.g7, SB.h8 )

    TEST_WITH_ARGS( 0, SB.e4, SB.e5 )
    TEST_WITH_ARGS( 0, SB.e4, SB.f5 )
    TEST_WITH_ARGS( 0, SB.e4, SB.f4 )
    TEST_WITH_ARGS( 0, SB.e4, SB.f3 )
    TEST_WITH_ARGS( 0, SB.e4, SB.e3 )
    TEST_WITH_ARGS( 0, SB.e4, SB.d3 )
    TEST_WITH_ARGS( 0, SB.e4, SB.d4 )
    TEST_WITH_ARGS( 0, SB.e4, SB.d5 )

#test C_in_between_tested_with_squares_with_one_in_between_squares
    TEST_WITH_ARGS( SB.a2, SB.a1, SB.a3 )
    TEST_WITH_ARGS( SB.b2, SB.a1, SB.c3 )
    TEST_WITH_ARGS( SB.b1, SB.a1, SB.c1 )

#test C_in_between_tested_with_squares_with_two_in_between_squares
    TEST_WITH_ARGS( SB.d5 | SB.d6, SB.d4, SB.d7 )
    TEST_WITH_ARGS( SB.e5 | SB.f6, SB.d4, SB.g7 )
    TEST_WITH_ARGS( SB.e4 | SB.f4, SB.d4, SB.g4 )
    TEST_WITH_ARGS( SB.e3 | SB.f2, SB.d4, SB.g1 )
    TEST_WITH_ARGS( SB.d3 | SB.d2, SB.d4, SB.d1 )
    TEST_WITH_ARGS( SB.b2 | SB.c3, SB.d4, SB.a1 )
    TEST_WITH_ARGS( SB.b4 | SB.c4, SB.d4, SB.a4 )
    TEST_WITH_ARGS( SB.b6 | SB.c5, SB.d4, SB.a7 )

    TEST_WITH_ARGS( SB.c1 | SB.d1, SB.b1, SB.e1 )
    TEST_WITH_ARGS( SB.c3 | SB.d2, SB.b4, SB.e1 )
    TEST_WITH_ARGS( SB.e2 | SB.e3, SB.e1, SB.e4 )
    TEST_WITH_ARGS( SB.f2 | SB.g3, SB.h4, SB.e1 )
    TEST_WITH_ARGS( SB.g1 | SB.f1, SB.e1, SB.h1 )

#test C_in_between_tested_with_corner_squares
    TEST_WITH_ARGS( SB.b2 | SB.c3 | SB.d4 | SB.e5 | SB.f6 | SB.g7,
        SB.a1, SB.h8 )
    TEST_WITH_ARGS( SB.g2 | SB.f3 | SB.e4 | SB.d5 | SB.c6 | SB.b7,
        SB.h1, SB.a8 )

#test C_in_between_tested_with_edge_squares
    TEST_WITH_ARGS( SB.b4 | SB.c4 | SB.d4 | SB.e4 | SB.f4 | SB.g4,
        SB.a4, SB.h4 )
    TEST_WITH_ARGS( SB.h2 | SB.h3 | SB.h4 | SB.h5 | SB.h6 | SB.h7,
        SB.h8, SB.h1 )

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase copy_pos_tests

#define TEST_WITH_ARGS( fen_arg ) \
    ck_assert( !che_fen_validator( fen_arg ) ); \
    Pos *p = fen_to_pos( fen_arg ); \
    Pos copy; \
    copy_pos( p, &copy ); \
    ck_assert( p->ppa[EMPTY_SQUARE] == copy.ppa[EMPTY_SQUARE] ); \
    ck_assert( p->ppa[WHITE_KING] == copy.ppa[WHITE_KING] ); \
    ck_assert( p->ppa[WHITE_QUEEN] == copy.ppa[WHITE_QUEEN] ); \
    ck_assert( p->ppa[WHITE_ROOK] == copy.ppa[WHITE_ROOK] ); \
    ck_assert( p->ppa[WHITE_BISHOP] == copy.ppa[WHITE_BISHOP] ); \
    ck_assert( p->ppa[WHITE_KNIGHT] == copy.ppa[WHITE_KNIGHT] ); \
    ck_assert( p->ppa[WHITE_PAWN] == copy.ppa[WHITE_PAWN] ); \
    ck_assert( p->ppa[BLACK_KING] == copy.ppa[BLACK_KING] ); \
    ck_assert( p->ppa[BLACK_QUEEN] == copy.ppa[BLACK_QUEEN] ); \
    ck_assert( p->ppa[BLACK_ROOK] == copy.ppa[BLACK_ROOK] ); \
    ck_assert( p->ppa[BLACK_BISHOP] == copy.ppa[BLACK_BISHOP] ); \
    ck_assert( p->ppa[BLACK_KNIGHT] == copy.ppa[BLACK_KNIGHT] ); \
    ck_assert( p->ppa[BLACK_PAWN] == copy.ppa[BLACK_PAWN] ); \
    ck_assert( p->turn_and_ca_flags == copy.turn_and_ca_flags ); \
    ck_assert( p->irp[0] == copy.irp[0] ); \
    ck_assert( p->irp[1] == copy.irp[1] ); \
    ck_assert( p->epts_file == copy.epts_file ); \
    ck_assert( p->hmc == copy.hmc ); \
    ck_assert( p->fmn == copy.fmn ); \
    free(p);

#test C_copy_pos_tested_with_std_start_pos
    TEST_WITH_ARGS( INIT_POS )

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase file_tests

#test file_test_01

    ck_assert( file('a') == 0x101010101010101U );
    ck_assert( file('b') ==
        (SB.b1 | SB.b2 | SB.b3 | SB.b4 | SB.b5 | SB.b6 | SB.b7 | SB.b8) );
    ck_assert( file('e') == 0x1010101010101010U );
    ck_assert( file('h') ==
        (SB.h1 | SB.h2 | SB.h3 | SB.h4 | SB.h5 | SB.h6 | SB.h7 | SB.h8) );

//
// Test case
//
#tcase rank_tests

#test rank_test_01

    ck_assert( rank('1') == 0xffU );
    ck_assert( rank('2') ==
        (SB.a2 | SB.b2 | SB.c2 | SB.d2 | SB.e2 | SB.f2 | SB.g2 | SB.h2) );
    ck_assert( rank('5') == 0xff00000000U );
    ck_assert( rank('8') ==
        (SB.a8 | SB.b8 | SB.c8 | SB.d8 | SB.e8 | SB.f8 | SB.g8 | SB.h8) );

//
// Test case
//
#tcase set_mover_target_orig_and_dest_tests

#define TEST_WITH_ARGS( \
        fen, move, exp_mover, exp_target, exp_orig, exp_dest ) \
    Chessman mover, target; \
    int orig, dest; \
    ck_assert( !che_fen_validator( fen ) ); \
    const Pos *p = fen_to_pos( fen ); \
    set_mover_target_orig_and_dest( p, rawcode(move), \
        &mover, &target, &orig, &dest ); \
    ck_assert( mover == exp_mover ); \
    ck_assert( target == exp_target ); \
    ck_assert( orig == exp_orig ); \
    ck_assert( dest == exp_dest ); \
    free( (Pos *) p );

#test set_mover_target_orig_and_dest_test_01
    TEST_WITH_ARGS( INIT_POS, "e2e4",
        WHITE_PAWN, EMPTY_SQUARE, 12, 28 )

#test set_mover_target_orig_and_dest_test_02
    TEST_WITH_ARGS(
        "nqrk2rn/ppp1ppbp/6p1/1b1p4/3P4/2P3N1/PPNBPPPP/1QRK1BR1 b CGcg - 2 5",
        "d8c8", BLACK_KING, BLACK_ROOK, 59, 58 )

#test set_mover_target_orig_and_dest_test_03
    TEST_WITH_ARGS(
        "nqrk2rn/ppp1ppbp/6p1/1b1p4/3P4/2P3N1/PPNBPPPP/1QRK1BR1 b CGcg - 2 5",
        "g7d4", BLACK_BISHOP, WHITE_PAWN, 54, 27 )

#undef TEST_WITH_ARGS

//
// Test case
//
#tcase next_line_tests

#define COMMA ,
#define TEST_WITH_ARGS(text, ordinal, expected_strings) \
    char *expected_ ## ordinal[] = expected_strings; \
    unmodified_ptr = (char *) malloc(strlen(text) + 1), \
        lines = unmodified_ptr; \
    strcpy(lines, text); \
    \
    index = -1; \
    while( (line = next_line(&lines)) ) { \
        ck_assert(!strcmp(line, expected_ ## ordinal[++index])); \
        ck_assert(lines > unmodified_ptr); } \
    \
    free(unmodified_ptr);

#test next_line_test_1
    char *unmodified_ptr, *lines, *line;
    int index;

    TEST_WITH_ARGS("hey\nyou", 1, {"hey" COMMA "you"})
    TEST_WITH_ARGS("this is a test", 2, {"this is a test"})
    TEST_WITH_ARGS("this is a test\n", 3, {"this is a test"})
    TEST_WITH_ARGS("this is\na test", 4, {"this is" COMMA "a test"})
    TEST_WITH_ARGS("this is\na test\n", 5, {"this is" COMMA "a test"})
    TEST_WITH_ARGS("a", 6, {"a"})
    TEST_WITH_ARGS("a\nb", 7, {"a" COMMA "b"})
    TEST_WITH_ARGS("a\nb\nc\n", 8, {"a" COMMA "b" COMMA "c"})

#undef COMMA
#undef TEST_WITH_ARGS

#test next_line_test_2
    char *unmodified_ptr = (char *) malloc(1), *lines = unmodified_ptr;
    strcpy(lines, "");

    for(int cntr = 1; cntr <= 3; cntr++) {
        ck_assert(next_line(&lines) == NULL);
        ck_assert(unmodified_ptr == lines); }

    free(unmodified_ptr);

#test next_line_test_3
    char str[] = "this\nis a\ntest\n";
    char *unmod_ptr = (char *) malloc(strlen(str) + 1), *lines = unmod_ptr,
        *line;
    strcpy(lines, str);

    // First call
    line = next_line(&lines);
    ck_assert(!strcmp(line, "this") && !strcmp(lines, "is a\ntest\n"));
    // Second call
    line = next_line(&lines);
    ck_assert(!strcmp(line, "is a") && !strcmp(lines, "test\n"));
    // Third call
    line = next_line(&lines);
    ck_assert(!strcmp(line, "test") && !strcmp(lines, ""));
    // Fourth call
    line = next_line(&lines);
    ck_assert(line == NULL && !strcmp(lines, ""));

    free(unmod_ptr);

//
// Test case
//
#tcase string_sort_tests

#define COMMA ,
#define TEST_WITH_ARGS(unsorted, expected_arg, suffix) \
    char *to_be_sorted_ ## suffix[] = unsorted, \
        *expected_ ## suffix[] = expected_arg; \
    int count_ ## suffix = sizeof(to_be_sorted_ ## suffix) / sizeof(char *); \
    string_sort(to_be_sorted_ ## suffix, count_ ## suffix); \
    for(int i = 0; i < count_ ## suffix; i++) { \
        /*printf("%s %s\n", to_be_sorted_ ## suffix[i], expected_ ## suffix[i] );*/ \
        ck_assert(to_be_sorted_ ## suffix[i] == expected_ ## suffix[i]); }

#test string_sort_test_1
    TEST_WITH_ARGS({"a" COMMA "b"}, {"a" COMMA "b"}, 1)
    TEST_WITH_ARGS({"b" COMMA "a"}, {"a" COMMA "b"}, 2)
    TEST_WITH_ARGS({"x" COMMA "x"}, {"x" COMMA "x"}, 3)
    TEST_WITH_ARGS({"h" COMMA "H"}, {"H" COMMA "h"}, 4);

#test string_sort_test_2
    TEST_WITH_ARGS({"THIS" COMMA "IS" COMMA "A" COMMA "TEST"},
        {"A" COMMA "IS" COMMA "TEST" COMMA "THIS"}, 1)
    TEST_WITH_ARGS({"These" COMMA "are" COMMA "many" COMMA "WORDS" COMMA "!"},
        {"!" COMMA "These" COMMA "WORDS" COMMA "are" COMMA "many"}, 2)

#undef COMMA
#undef TEST_WITH_ARGS

//
// Test case
//
#tcase bindex_tests

#test bindex_trivial_test
    ck_assert(bindex((Bitboard) 0) == -1);
    ck_assert(bindex((Bitboard) 1) == 0);
    ck_assert(bindex((Bitboard) 2) == 1);
    ck_assert(bindex((Bitboard) 4) == 2);
    ck_assert(bindex((Bitboard) 256) == 8);
    ck_assert(bindex((Bitboard) 256) == 8);
    ck_assert(bindex((Bitboard) 0x4000000000000000ULL) == 62);
    ck_assert(bindex((Bitboard) 0x8000000000000000ULL) == 63);

#test bindex_comprehensive_test
    Bitboard bit = 1;
    const Bitboard ONE = 1;
    int expected_bit_index = 0;

    while(true) {
        ck_assert(bindex(bit) == expected_bit_index);
        ck_assert(sq_bit_index(bit) == expected_bit_index);
        if(bit == (ONE << 63)) break;
        bit <<= 1, ++expected_bit_index; }

    ck_assert(expected_bit_index == 63);

//
// Test case
//
#tcase white_army_tests

#test white_army_std_start_pos
    const Pos *p = fen_to_pos(INIT_POS);
    ck_assert(white_army(p) == 0xffffU);
    free((void *) p);

//
// Test case
//
#tcase black_army_tests

#test black_army_std_start_pos
    const Pos *p = fen_to_pos(INIT_POS);
    ck_assert(black_army(p) == 0xffff000000000000U);
    free((void *) p);

//
// Test case
//
#tcase sq_name_to_bindex_tests

#test sq_name_to_bindex_comprehensive_test
    int expected = 0, actual;
    char sq_name[2 + 1] = {'\0'};

    for(int rank = '1'; rank <= '8'; ++rank) {
        for(int file = 'a'; file <= 'h'; ++file, ++expected) {
            sq_name[0] = file, sq_name[1] = rank;
            actual = sq_name_to_bindex(sq_name);
            ck_assert(actual == expected);
        }
    }
